<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vless节点生成工具</title>
    <link rel="stylesheet" href="./style.css">
</head>

<body>
    <!-- 全局通知容器 -->
    <div class="notification-container" id="notificationContainer"></div>

    <div class="container">
        <!-- 顶部信息提示条（可隐藏） -->
        <div class="header-info" id="headerInfo">
            <button class="toggle-header-btn" id="toggleHeaderBtn">隐藏</button>
            <h1>Vless节点生成工具</h1>
            <p>CSV转Vless + Base64订阅 + GitHub自动同步</p>
        </div>

        <!-- 快捷操作按钮组（调整了顺序） -->
        <div class="quick-actions">
            <button class="quick-btn" onclick="generateVless()">
                <span>⚡</span> 生成节点
            </button>
            <button class="quick-btn" onclick="downloadRemote()">
                <span>⬇️</span> 下载远程
            </button>
            <button class="quick-btn" onclick="mergeAndShow()">
                <span>🔄</span> 合并节点
            </button>
            <button class="quick-btn" onclick="oneClickSync()">
                <span>🚀</span> 一键同步
            </button>
            <button class="quick-btn" onclick="uploadLocalBase64ToPath()">
                <span>📤</span> 上传本地订阅至指定路径
            </button>
            <button class="quick-btn" onclick="uploadMergedBase64()">
                <span>📤</span> 上传合并主要订阅
            </button>
            <button class="quick-btn" onclick="uploadMergedOptimal()">
                <span>📤</span> 上传合并优选订阅
            </button>
            <button class="quick-btn" onclick="uploadPlainNodes()">
                <span>📤</span> 上传合并明文订阅
            </button>
            <button class="quick-btn" onclick="toggleLog()">
                <span>📋</span> 显示日志
            </button>
            <button class="quick-btn" onclick="document.getElementById('toggleHeaderBtn').click()">
                <span>👁️</span> 显示/隐藏标题
            </button>
        </div>

        <div class="main-layout">
            <!-- CSV数据源卡片 - 最常用 -->
            <div class="card">
                <div class="card-header">
                    <h2>
                        <span>📁</span>
                        CSV数据源
                        <span id="sourceBadge" class="source-badge">未选择</span>
                    </h2>
                </div>
                <div class="card-body">
                    <!-- CSV数据源标签页导航 -->
                    <div class="card-tab-navigation" id="csvTabNav">
                        <button class="card-tab-btn active" data-tab="upload-tab">上传文件</button>
                        <button class="card-tab-btn" data-tab="paste-tab">粘贴内容</button>
                        <button class="card-tab-btn" data-tab="config-tab">配置</button>
                    </div>

                    <!-- 上传文件标签页 -->
                    <div class="card-tab-content active" id="upload-tab">
                        <div class="section">
                            <div class="file-upload-container">
                                <div class="file-upload-area" id="dropArea">
                                    <div class="upload-icon">📁</div>
                                    <p><strong>拖放CSV文件到此处，或点击选择</strong></p>
                                    <small>支持.csv或.txt文件格式</small>
                                    <input type="file" id="fileInput" accept=".csv,.txt">
                                </div>

                                <div id="fileInfo" class="file-info">
                                    <div class="file-info-content">
                                        <div class="file-info-text">
                                            <span id="fileName" class="file-name"></span>
                                            <span id="fileSize" class="file-size"></span>
                                        </div>
                                        <button type="button" id="removeFileBtn" class="remove-file-btn">
                                            <span>🗑️</span> 移除
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div class="section-title">
                                <span>📊 CSV列配置</span>
                                <button class="btn btn-info"
                                    style="padding: 6px 12px; font-size: 12px; margin-left: auto;"
                                    onclick="autoDetectCSVColumns()">
                                    <span>🔍</span> 智能检测列
                                </button>
                            </div>

                            <div id="columnDetectionResult"
                                style="display: none; margin-bottom: 16px; padding: 12px; background: #f0f9ff; border-radius: 6px; border: 1px solid #b6e0fe;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 0px;">
                                    <span style="font-weight: bold; color: #1e40af;">🔍 检测结果:</span>
                                    <span id="detectionSummary" style="color: #4b5563;"></span>
                                </div>
                                <div style="font-size: 12px; color: #6b7280;" id="detectionDetails"></div>
                            </div>

                            <div class="csv-config-row">
                                <div class="csv-form-group">
                                    <label for="ipColumn">IP地址列 <span class="help-inline">A列=0，B列=1</span></label>
                                    <div class="input-row">
                                        <input type="number" id="ipColumn" value="0" min="0">
                                    </div>
                                </div>
                                <div class="csv-form-group">
                                    <label for="portColumn">端口列 <span class="help-inline">-1表示无端口列</span></label>
                                    <div class="input-row">
                                        <input type="number" id="portColumn" value="-1" min="-1">
                                    </div>
                                </div>
                                <div class="csv-form-group">
                                    <label for="cityColumn">城市列 <span class="help-inline">优先用于别名</span></label>
                                    <div class="input-row">
                                        <input type="number" id="cityColumn" value="-1" min="-1">
                                    </div>
                                </div>
                            </div>

                            <div class="csv-config-row">
                                <div class="csv-form-group">
                                    <label for="countryColumn">国家列 <span class="help-inline">用于显示国家</span></label>
                                    <div class="input-row">
                                        <input type="number" id="countryColumn" value="-1" min="-1">
                                    </div>
                                </div>
                                <div class="csv-form-group">
                                    <label for="regionColumn">地区码列 <span class="help-inline">如机场/州代码</span></label>
                                    <div class="input-row">
                                        <input type="number" id="regionColumn" value="-1" min="-1">
                                    </div>
                                </div>
                                <div class="csv-form-group">
                                    <label for="speedColumn">下载速度列 <span class="help-inline">用于别名展示</span></label>
                                    <div class="input-row">
                                        <input type="number" id="speedColumn" value="-1" min="-1">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 粘贴内容标签页 -->
                    <div class="card-tab-content" id="paste-tab">
                        <div class="section">
                            <div class="section-title">
                                <span>📝 粘贴CSV或IP和端口内容</span>
                            </div>

                            <div class="form-group">
                                <label for="csvInput">CSV数据内容：</label>
                                <textarea id="csvInput" placeholder="支持多种格式，智能分割：
1. 单行或多行格式：
2. 紧凑格式（一行多个）：
3. 混合分隔符：
4. 只有IP（使用默认端口）："></textarea>
                            </div>

                            <!-- 智能分割说明 -->
                            <div class="smart-split-info">
                                <h4>📋 智能分割说明</h4>
                                <p>支持以下格式（自动识别）：</p>
                                <ul>
                                    <li>IP:端口（冒号分隔）</li>
                                    <li>IP,端口（逗号分隔）</li>
                                    <li>IP 端口（单个或多个空格分隔）</li>
                                    <li>IP;端口（分号分隔）</li>
                                    <li>只有IP（使用默认端口）</li>
                                </ul>
                                <p>支持混合格式和紧凑格式，自动去重和清理。</p>
                                <!-- CSV格式示例 -->
                                <div class="csv-example">
                                    <strong>示例：</strong><br>
                                    8.209.202.241:443<br>
                                    104.238.162.245,8080<br>
                                    45.76.123.234 8443<br>
                                    142.93.128.233<br>
                                    15.25.152.123 8443 (多个空格)
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- 配置标签页 -->
                    <div class="card-tab-content" id="config-tab">
                        <div class="section">
                            <div class="section-title">
                                <span>⚙️ 节点配置</span>
                            </div>

                            <div class="config-row">
                                <div class="form-group">
                                    <label for="defaultPort">默认端口</label>
                                    <input type="number" id="defaultPort" value="443" min="1" max="65535">
                                </div>

                                <div class="form-group">
                                    <label for="remarksPrefix">别名前缀</label>
                                    <input type="text" id="remarksPrefix" value="自选">
                                </div>
                            </div>

                            <div class="checkbox-group">
                                <input type="checkbox" id="forcePort443">
                                <label for="forcePort443"><strong>强制所有节点使用443端口</strong></label>
                            </div>

                            <div class="checkbox-group">
                                <input type="checkbox" id="autoLocation" checked>
                                <label for="autoLocation"><strong>自动识别IP属地生成别名</strong></label>
                            </div>

                            <div class="checkbox-group">
                                <input type="checkbox" id="renameOnMerge" checked>
                                <label for="renameOnMerge"><strong>合并时重新设置所有节点别名</strong></label>
                            </div>
                            <!-- 新增：使用CSV信息生成别名 -->
                            <div class="checkbox-group">
                                <input type="checkbox" id="useCsvInfo" checked>
                                <label for="useCsvInfo"><strong>优先使用CSV信息生成别名</strong></label>
                            </div>
                        </div>
                    </div>

                    <!-- 生成按钮区域 -->
                    <div class="generate-section">
                        <div class="section-title">
                            <span>🚀 生成操作</span>
                            <span id="localNodeCount" class="node-counter">0节点</span>
                        </div>

                        <button id="generateBtn" class="btn btn-primary btn-block">
                            <span>⚡</span> 生成Vless节点
                        </button>

                        <div class="loading" id="loading">
                            <div class="loading-spinner"></div>
                            <p>正在处理数据，请稍候...</p>
                        </div>
                    </div>

                    <!-- 高级配置折叠面板 -->
                    <div class="accordion">
                        <div class="accordion-header" id="advancedConfigToggle">
                            <span>⚙️ 高级配置（固定默认值）</span>
                            <span class="icon">▼</span>
                        </div>
                        <div class="accordion-content" id="advancedConfigContent">
                            <div class="config-row">
                                <div class="form-group">
                                    <label>用户ID (UUID)</label>
                                    <input type="text" id="uuid" value="471a8e64-7b21-4703-b1d1-45a221098459" readonly>
                                </div>

                                <div class="form-group">
                                    <label>伪装域名 (Host)</label>
                                    <input type="text" id="host" value="knny.dpdns.org">
                                </div>
                            </div>

                            <div class="config-row">
                                <div class="form-group">
                                    <label>SNI域名</label>
                                    <input type="text" id="sni" value="knny.dpdns.org">
                                </div>

                                <div class="form-group">
                                    <label>浏览器指纹 (fp)</label>
                                    <input type="text" id="fp" value="chrome">
                                </div>
                            </div>

                            <div class="help-text">
                                其他固定参数：<br>
                                • 加密方式：none<br>
                                • 网络类型：ws<br>
                                • Path：/<br>
                                • TLS：启用<br>
                                • Flow：空<br>
                                • 伪装方式：空
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 生成结果卡片 - 常用 -->
            <div class="card">
                <div class="card-header">
                    <h2>
                        <span>📊</span>
                        生成结果（节点汇总）
                        <span id="resultCount" class="badge">0节点</span>
                    </h2>
                </div>
                <div class="card-body">
                    <!-- 生成结果标签页 -->
                    <div class="card-tab-navigation" id="resultTabNav">
                        <button class="card-tab-btn active" data-tab="vless-tab">本地Vless</button>
                        <button class="card-tab-btn" data-tab="local-base64-tab">本地订阅包</button>
                        <button class="card-tab-btn" data-tab="merged-tab">合并Vless</button>
                        <button class="card-tab-btn" data-tab="auto-base64-tab">合并订阅包</button>
                        <button class="card-tab-btn" data-tab="proxy-tools-tab">代理工具</button>
                    </div>

                    <!-- Vless链接标签页 -->
                    <div class="card-tab-content active" id="vless-tab">
                        <div class="result-header">
                            <h3>🔗 Vless链接（本地生成）</h3>
                            <button id="copyVlessBtn" class="btn btn-success">
                                <span>📋</span> 复制全部Vless链接
                            </button>
                        </div>
                        <div class="result-box">
                            <div id="vless-links" class="result-content empty">Vless链接将在这里显示...</div>
                        </div>

                        <div class="button-group" style="margin-top: 14px;">
                            <!-- 只保留一个下载按钮 -->
                            <button id="downloadAllBtn" class="btn btn-success">
                                <span>📁</span> 下载明文订阅文件
                            </button>
                        </div>
                    </div>

                    <!-- 本地订阅包标签页 -->
                    <div class="card-tab-content" id="local-base64-tab">
                        <div class="result-header">
                            <h3>🔗 Base64订阅（本地生成）</h3>
                            <button id="copyLocalBase64Btn" class="btn btn-success">
                                <span>📋</span> 复制Base64
                            </button>
                        </div>
                        <div class="result-box">
                            <div id="localBase64Output" class="result-content empty">Base64订阅内容将在这里显示...</div>
                        </div>
                        <div class="result-header" style="margin-top: 20px;">
                            <h3>📄 本地YAML配置</h3>
                            <div class="button-group">
                                <button id="copyLocalYamlBtn" class="btn btn-info">
                                    <span>📋</span> 复制YAML
                                </button>
                                <button id="downloadLocalYamlBtn" class="btn btn-primary">
                                    <span>📁</span> 下载YAML
                                </button>
                            </div>
                        </div>
                        <div class="result-box">
                            <div id="localYamlOutput" class="result-content empty">本地YAML配置将在这里显示...</div>
                        </div>
                        <div class="help-text">
                            此Base64可直接作为订阅链接导入Clash、Shadowrocket等工具
                        </div>
                    </div>

                    <!-- 合并结果标签页 -->
                    <div class="card-tab-content" id="merged-tab">
                        <div class="result-header">
                            <h3>🔄 合并结果预览（明文）</h3>
                            <button id="copyMergedBtn" class="btn btn-success">
                                <span>📋</span> 复制明文
                            </button>
                        </div>
                        <div class="result-box">
                            <div id="mergedResult" class="result-content empty">合并后的节点将在这里显示...</div>
                        </div>
                    </div>

                    <!-- 合并订阅包标签页 -->
                    <div class="card-tab-content" id="auto-base64-tab">
                        <div class="result-header">
                            <h3>🔗 Base64订阅（本地+远程合并）</h3>
                            <button id="copyAutoBase64Btn" class="btn btn-success">
                                <span>📋</span> 复制Base64
                            </button>
                        </div>
                        <div class="result-box">
                            <div id="autoBase64Output" class="result-content empty">合并去重后将自动生成Base64订阅内容...</div>
                        </div>
                        <div class="result-header" style="margin-top: 20px;">
                            <h3>📄 合并结果YAML配置</h3>
                            <div class="button-group">
                                <button id="copyMergedYamlBtn" class="btn btn-info">
                                    <span>📋</span> 复制YAML
                                </button>
                                <button id="downloadMergedYamlBtn" class="btn btn-primary">
                                    <span>📁</span> 下载YAML
                                </button>
                            </div>
                        </div>
                        <div class="result-box">
                            <div id="mergedYamlOutput" class="result-content empty">合并后的YAML配置将在这里显示...</div>
                        </div>
                    </div>

                    <!-- 代理工具标签页 -->
                    <div class="card-tab-content" id="proxy-tools-tab">
                        <div class="result-header">
                            <h3>🔧 代理工具配置文件下载</h3>
                        </div>
                        <div class="proxy-tools-grid">
                            <div class="proxy-tool-item">
                                <div class="tool-icon">⚡</div>
                                <div class="tool-info">
                                    <h4>Clash</h4>
                                    <p>YAML配置文件</p>
                                </div>
                                <button id="downloadClashBtn" class="btn btn-info">
                                    <span>⬇️</span> 下载YAML
                                </button>
                            </div>
                        </div>
                        <div class="help-text" style="margin-top: 16px;">
                            选择代理工具下载对应的配置文件或订阅链接
                        </div>
                    </div>
                </div>
            </div>

            <!-- GitHub同步卡片 - 次常用 -->
            <div class="card">
                <div class="card-header">
                    <h2>
                        <span>🐙</span>
                        GitHub订阅同步
                        <span class="node-counter" id="syncNodeCount">0节点</span>
                    </h2>
                </div>
                <div class="card-body">
                    <div class="github-config">
                        <!-- GitHub配置帮助文本 - 放在右上角 -->
                        <div class="github-config-help">
                            GitHub API令牌 <a href="https://github.com/settings/tokens" target="_blank">获取令牌</a>:需repo权限
                            <a href="#" onclick="copyGitToken()">复制查看示例令牌</a>
                        </div>

                        <div class="section-title">
                            <span>🔧 GitHub配置</span>
                        </div>

                        <!-- 将 GitHub 配置分为两个标签页：常用（保留三个主要输入）与高级（不常用） -->
                        <div class="card-tab-navigation" id="githubConfigTabNav">
                            <button class="card-tab-btn active" data-tab="github-basic-tab">常用</button>
                            <button class="card-tab-btn" data-tab="github-advanced-tab">高级（不常用）</button>
                        </div>

                        <!-- 常用标签：令牌 单独一行；路径选择保持原先次序：下载在前，上传在后 -->
                        <div class="card-tab-content active" id="github-basic-tab">
                            <div class="form-group">
                                <label for="githubToken" class="token-label">GitHub令牌：</label>
                                <div style="display:flex; gap:12px; align-items:center;">
                                    <input type="password" id="githubToken" placeholder="ghp_XXXXXXXXXXXXXXXXXXXX"
                                        style="flex:1;">
                                    <label class="token-save-label" for="saveToken">
                                        <input type="checkbox" id="saveToken" checked>
                                        保存令牌到本地存储
                                    </label>
                                </div>
                            </div>

                            <div class="path-select-row">
                                <div class="form-group">
                                    <label for="downloadUrlSelect">下载远程订阅路径：</label>
                                    <select id="downloadUrlSelect">
                                        <option value="MainNode">MainNode（主要订阅）</option>
                                        <option value="OptimalNode">OptimalNode（优选订阅）</option>
                                        <option value="PlainNode">PlainNode（明文订阅）</option>
                                        <option value="custom">自定义路径</option>
                                    </select>
                                    <input type="text" id="customDownloadUrl" class="custom-url-input"
                                        placeholder="输入自定义路径，如：OtherNode">
                                    <div class="help-text">选择要下载的远程订阅文件路径</div>
                                </div>

                                <div class="form-group">
                                    <label for="uploadPathSelect">订阅待上传路径：</label>
                                    <select id="uploadPathSelect">
                                        <option value="OptimalNode">OptimalNode（优选订阅）</option>
                                        <option value="MainNode">MainNode（主要订阅）</option>
                                        <option value="PlainNode">PlainNode（明文订阅）</option>
                                        <option value="custom">自定义路径</option>
                                    </select>
                                    <input type="text" id="customUploadPath" class="custom-url-input"
                                        placeholder="输入自定义路径，如：OtherNode">
                                    <div class="help-text">选择订阅的待上传到远程的路径</div>
                                </div>
                            </div>
                        </div>

                        <!-- 高级标签（移动不常用项：仓库、分支、文件名、链接类型） -->
                        <div class="card-tab-content" id="github-advanced-tab">
                            <div class="config-row">
                                <div class="form-group">
                                    <label for="githubRepo">GitHub仓库：</label>
                                    <input type="text" id="githubRepo" value="DaiZhouHui/CustomNode">
                                </div>

                                <div class="form-group">
                                    <label for="githubBranch">分支：</label>
                                    <input type="text" id="githubBranch" value="main">
                                </div>
                            </div>

                            <div class="config-row">
                                <div class="form-group">
                                    <label for="optimalNodeFile">优选订阅文件</label>
                                    <input type="text" id="optimalNodeFile" value="OptimalNode">
                                </div>

                                <div class="form-group">
                                    <label for="mainNodeFile">主要订阅文件</label>
                                    <input type="text" id="mainNodeFile" value="MainNode">
                                </div>

                                <div class="form-group">
                                    <label for="plainNodeFile">明文订阅文件</label>
                                    <input type="text" id="plainNodeFile" value="PlainNode">
                                </div>
                            </div>

                            <!-- 单独一行：删除远程文件（及其 .yaml）功能 -->
                            <div class="config-row">
                                <div class="form-group" style="width:100%;">
                                    <label for="deleteFileName">删除远程文件及其对应yaml文件（输入文件名）</label>
                                    <div style="display:flex; gap:8px; align-items:center;">
                                        <input type="text" id="deleteFileName" placeholder="例如：OptimalNode"
                                            style="flex:1;" />
                                        <button id="deleteRemoteFileBtn" class="btn btn-warning">删除指定路径文件</button>
                                    </div>
                                    <div class="help-text">将删除 GitHub 仓库中对应的文件及同名的 .yaml 文件，请谨慎操作。<a
                                            href="https://github.com/DaiZhouHui/CustomNode"
                                            target="_blank">访问CustomNode</a></div>
                                </div>
                            </div>

                            <div class="config-row">
                                <div class="form-group">
                                    <label for="fileLinkTypeSelect">生成链接类型（默认 GitHub Pages）</label>
                                    <select id="fileLinkTypeSelect">
                                        <option value="pages">GitHub Pages（https://{user}.github.io/{repo}/...）</option>
                                        <option value="raw">Raw（https://raw.githubusercontent.com/...）</option>
                                    </select>
                                    <div class="help-text">选择网页上显示/复制的链接类型，默认使用 GitHub Pages</div>
                                </div>
                            </div>
                            <!-- 已移除：定时同步（浏览器端）功能（按要求删去） -->
                        </div>
                    </div>

                    <!-- GitHub操作按钮 - 重新调整布局 -->
                    <div class="github-buttons">
                        <!-- 第一行：三个按钮 -->
                        <div class="github-buttons-row1">
                            <button id="downloadSubBtn" class="btn btn-primary">
                                <span>⬇️</span> 下载远程订阅
                            </button>
                            <button id="mergeBtn" class="btn btn-success">
                                <span>🔄</span> 本地与远程合并去重
                            </button>
                            <button id="uploadLocalBase64ToPathBtn" class="btn btn-local-upload">
                                <span>📤</span> 上传本地订阅至指定路径
                            </button>
                        </div>

                        <!-- 第二行：三个按钮 -->
                        <div class="github-buttons-row2">
                            <button id="uploadMergedOptimalBtn" class="btn btn-upload-merged">
                                <span>📤</span> 上传合并优选订阅
                            </button>
                            <button id="uploadMergedBase64Btn" class="btn btn-subscription-upload">
                                <span>📤</span> 上传合并的主要订阅
                            </button>
                            <button id="uploadPlainNodesBtn" class="btn btn-merge-upload">
                                <span>📤</span> 上传合并明文订阅
                            </button>
                        </div>

                        <!-- 第三行：新增"上传合并订阅至指定路径"和"一键同步"按钮 -->
                        <div class="github-buttons-row3">
                            <button id="uploadMergedToPathBtn" class="btn btn-merge-to-path btn-block">
                                <span>📤</span> 上传合并订阅至指定路径
                            </button>
                            <button id="syncBtn" class="btn btn-oneclick-sync btn-block">
                                <span>🚀</span> 一键同步（全部上传）
                            </button>
                        </div>
                    </div>

                    <!-- GitHub.io链接显示区域 -->
                    <div class="github-links-section" id="githubLinksSection" style="display: none;">
                        <h3>🔗 GitHub.io 订阅链接</h3>
                        <div class="github-links-container">
                            <div class="github-link-item" id="plainNodesLink" style="display: none;">
                                <div class="link-label">明文订阅链接：</div>
                                <div class="link-content">
                                    <input type="text" id="plainNodesUrl" readonly class="link-input">
                                    <button id="copyPlainNodesUrl" class="btn btn-info btn-sm">
                                        <span>📋</span> 复制
                                    </button>
                                    <button class="btn btn-primary btn-sm"
                                        onclick="showQR(document.getElementById('plainNodesUrl').value, '明文订阅')">
                                        <span>🔍</span> 二维码
                                    </button>
                                </div>
                            </div>
                            <div class="github-link-item" id="mergedBase64Link" style="display: none;">
                                <div class="link-label">合并Base64订阅链接：</div>
                                <div class="link-content">
                                    <input type="text" id="mergedBase64Url" readonly class="link-input">
                                    <button id="copyMergedBase64Url" class="btn btn-info btn-sm">
                                        <span>📋</span> 复制
                                    </button>
                                    <button class="btn btn-primary btn-sm"
                                        onclick="showQR(document.getElementById('mergedBase64Url').value, '合并Base64订阅')">
                                        <span>🔍</span> 二维码
                                    </button>
                                </div>
                            </div>
                            <div class="github-link-item" id="mergedYamlLink" style="display: none;">
                                <div class="link-label">合并YAML配置链接：</div>
                                <div class="link-content">
                                    <input type="text" id="mergedYamlUrl" readonly class="link-input">
                                    <button id="copyMergedYamlUrl" class="btn btn-info btn-sm">
                                        <span>📋</span> 复制
                                    </button>
                                    <button class="btn btn-primary btn-sm"
                                        onclick="showQR(document.getElementById('mergedYamlUrl').value, '合并YAML')">
                                        <span>🔍</span> 二维码
                                    </button>
                                </div>
                            </div>
                            <div class="github-link-item" id="mergedOptimalLink" style="display: none;">
                                <div class="link-label">优选订阅链接：</div>
                                <div class="link-content">
                                    <input type="text" id="mergedOptimalUrl" readonly class="link-input">
                                    <button id="copyMergedOptimalUrl" class="btn btn-info btn-sm">
                                        <span>📋</span> 复制
                                    </button>
                                    <button class="btn btn-primary btn-sm"
                                        onclick="showQR(document.getElementById('mergedOptimalUrl').value, '优选订阅')">
                                        <span>🔍</span> 二维码
                                    </button>
                                </div>
                            </div>
                            <div class="github-link-item" id="localBase64Link" style="display: none;">
                                <div class="link-label">本地订阅链接：</div>
                                <div class="link-content">
                                    <input type="text" id="localBase64Url" readonly class="link-input">
                                    <button id="copyLocalBase64Url" class="btn btn-info btn-sm">
                                        <span>📋</span> 复制
                                    </button>
                                    <button class="btn btn-primary btn-sm"
                                        onclick="showQR(document.getElementById('localBase64Url').value, '本地订阅')">
                                        <span>🔍</span> 二维码
                                    </button>
                                </div>
                            </div>
                            <div class="github-link-item" id="localYamlLink" style="display: none;">
                                <div class="link-label">本地YAML配置链接：</div>
                                <div class="link-content">
                                    <input type="text" id="localYamlUrl" readonly class="link-input">
                                    <button id="copyLocalYamlUrl" class="btn btn-info btn-sm">
                                        <span>📋</span> 复制
                                    </button>
                                    <button class="btn btn-primary btn-sm"
                                        onclick="showQR(document.getElementById('localYamlUrl').value, '本地YAML')">
                                        <span>🔍</span> 二维码
                                    </button>
                                </div>
                            </div>
                            <div class="github-link-item" id="mergedToPathLink" style="display: none;">
                                <div class="link-label">指定路径订阅链接：</div>
                                <div class="link-content">
                                    <input type="text" id="mergedToPathUrl" readonly class="link-input">
                                    <button id="copyMergedToPathUrl" class="btn btn-info btn-sm">
                                        <span>📋</span> 复制
                                    </button>
                                    <button class="btn btn-primary btn-sm"
                                        onclick="showQR(document.getElementById('mergedToPathUrl').value, '指定路径订阅')">
                                        <span>🔍</span> 二维码
                                    </button>
                                </div>
                            </div>
                            <div class="github-link-item" id="yamlConfigLink" style="display: none;">
                                <div class="link-label">YAML配置文件链接：</div>
                                <div class="link-content">
                                    <input type="text" id="yamlConfigUrl" readonly class="link-input">
                                    <button id="copyYamlConfigUrl" class="btn btn-info btn-sm">
                                        <span>📋</span> 复制
                                    </button>
                                    <button class="btn btn-primary btn-sm"
                                        onclick="showQR(document.getElementById('yamlConfigUrl').value, 'YAML配置')">
                                        <span>🔍</span> 二维码
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- GitHub统计 -->
                    <div class="github-stats" id="githubStats" style="display: none;">
                        <div class="stat-item">
                            <span class="stat-label">本地节点</span>
                            <span class="stat-value" id="localNodes">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">远程节点</span>
                            <span class="stat-value" id="remoteNodes">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">合并节点</span>
                            <span class="stat-value" id="mergedNodes">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">去重后节点</span>
                            <span class="stat-value" id="uniqueNodes">0</span>
                        </div>
                    </div>

                    <!-- 日志记录区域 -->
                    <div class="log-section" id="logSection">
                        <div class="log-header">
                            <h3>📝 操作日志</h3>
                            <div class="log-controls">
                                <button id="clearLogBtn" class="btn btn-info"
                                    style="padding: 6px 12px; font-size: 12px;">
                                    <span>🗑️</span> 清空日志
                                </button>
                                <button id="toggleLogBtn" class="btn btn-info"
                                    style="padding: 6px 12px; font-size: 12px;">
                                    <span>📋</span> 收起日志
                                </button>
                            </div>
                        </div>
                        <div class="log-content" id="logContent">
                            <div class="log-entry">
                                <span class="log-time" id="logTime">[系统启动]</span>
                                <span class="log-level info">信息</span>
                                <span class="log-message">Vless节点生成工具已启动</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 手动转换卡片 - 最少用 -->
            <div class="card">
                <div class="card-header">
                    <h2>
                        <span>🔄</span>
                        手动Vless转换工具
                    </h2>
                </div>
                <div class="card-body">
                    <!-- 手动转换工具标签页导航 -->
                    <div class="card-tab-navigation" id="manualTabNav">
                        <button class="card-tab-btn active" data-tab="base64-tab">转Base64</button>
                        <button class="card-tab-btn" data-tab="ip-port-tab">转IP:端口</button>
                        <button class="card-tab-btn" data-tab="yaml-tab">转YAML</button>
                    </div>

                    <!-- 转Base64标签页 -->
                    <div class="card-tab-content active" id="base64-tab">
                        <div class="form-group">
                            <label for="manualVlessInput">粘贴Vless节点（每行一个）</label>
                            <textarea id="manualVlessInput" placeholder="粘贴vless://开头的节点链接，每行一个"></textarea>
                        </div>
                        <div class="button-group">
                            <button id="convertToBase64Btn" class="btn btn-success">
                                <span>🔗</span> 转换为Base64
                            </button>
                            <button id="copyManualBase64Btn" class="btn btn-info">
                                <span>📋</span> 复制Base64
                            </button>
                        </div>
                        <div class="result-box" id="manualBase64Section" style="display: none; margin-top: 12px;">
                            <div class="result-header">
                                <h3>手动转换的Base64订阅</h3>
                            </div>
                            <div id="manualBase64Output" class="result-content empty">Base64内容将在这里显示...</div>
                        </div>
                    </div>

                    <!-- 转IP:端口标签页 -->
                    <div class="card-tab-content" id="ip-port-tab">
                        <div class="form-group">
                            <label for="manualVlessInput2">粘贴Vless节点（每行一个）</label>
                            <textarea id="manualVlessInput2" placeholder="粘贴vless://开头的节点链接，每行一个"></textarea>
                        </div>
                        <div class="button-group">
                            <button id="convertToIpPortBtn" class="btn btn-success">
                                <span>🔗</span> 提取IP:端口
                            </button>
                            <button id="copyIpPortBtn" class="btn btn-info">
                                <span>📋</span> 复制IP:端口
                            </button>
                            <button id="downloadIpPortBtn" class="btn btn-primary">
                                <span>📁</span> 下载TXT
                            </button>
                        </div>
                        <div class="result-box" id="manualIpPortSection" style="display: none; margin-top: 12px;">
                            <div class="result-header">
                                <h3>提取的IP:端口列表</h3>
                            </div>
                            <div id="manualIpPortOutput" class="result-content empty">IP:端口列表将在这里显示...</div>
                        </div>
                    </div>

                    <!-- 转YAML标签页 -->
                    <div class="card-tab-content" id="yaml-tab">
                        <div class="form-group">
                            <label for="manualVlessInput3">粘贴Vless节点（每行一个）</label>
                            <textarea id="manualVlessInput3" placeholder="粘贴vless://开头的节点链接，每行一个"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="yamlFileName">YAML文件名（可选，默认为 clash-config.yaml）</label>
                            <input type="text" id="yamlFileName" placeholder="clash-config.yaml"
                                value="clash-config.yaml">
                        </div>
                        <div class="button-group">
                            <button id="convertToYamlBtn" class="btn btn-success">
                                <span>🔧</span> 转换为YAML
                            </button>
                            <button id="testParseBtn" class="btn btn-info">
                                <span>🧪</span> 测试解析
                            </button>
                            <button id="copyYamlBtn" class="btn btn-info">
                                <span>📋</span> 复制YAML
                            </button>
                            <button id="downloadYamlBtn" class="btn btn-primary">
                                <span>📁</span> 下载YAML
                            </button>
                            <button id="uploadYamlBtn" class="btn btn-upload-yaml">
                                <span>📤</span> 上传YAML
                            </button>
                        </div>
                        <div class="result-box" id="manualYamlSection" style="display: none; margin-top: 12px;">
                            <div class="result-header">
                                <h3>转换的Clash YAML配置</h3>
                            </div>
                            <div id="manualYamlOutput" class="result-content empty">YAML配置将在这里显示...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>© <span id="versionText">Vless节点生成工具</span></p>
        </div>
    </div>
    <script src="./js/map.js"></script>
    <script src="./js/ip-geolocation.js"></script>
    <script>
        // UTF-8 转 Base64 编码函数
        function utf8ToBase64(str) {
            const bytes = new TextEncoder().encode(str);
            const binString = Array.from(bytes, (byte) =>
                String.fromCodePoint(byte)
            ).join("");
            return btoa(binString);
        }

        // 全局数据
        let data = {
            vlessLinks: [],
            localBase64Content: '',  // 本地生成自动Base64
            localYamlContent: '',    // 本地生成的YAML
            autoBase64Content: '',   // 合并后自动Base64
            manualBase64Content: '', // 手动转换Base64
            manualIpPortContent: '', // 手动提取IP:端口
            manualYamlContent: '',   // 手动转换YAML
            mergedYamlContent: '',   // 合并生成的YAML
            remoteNodes: [],
            uniqueNodes: [],
            nodeSha: null,
            plainSha: null,
            optimalSha: null, // 新增：优选订阅文件的sha
            locationSha: null, // 本地生成Base64文件的sha
            stats: { local: 0, remote: 0, merged: 0, unique: 0 },
            currentSource: 'none',
            // 新增：缓存管理数据
            cache: {
                remoteNodes: [],      // 远程节点缓存
                lastDownloadTime: 0,  // 上次下载时间戳f
                downloadPath: '',     // 上次下载的路径
                needsUpdate: false,   // 标记缓存是否需要更新
                lastLocalGeneration: 0 // 上次本地生成节点时间
            },
            // 新增：CSV列检测结果
            csvColumnDetection: {
                ipColumn: 0,
                portColumn: -1,
                cityColumn: -1,
                countryColumn: -1,
                regionColumn: -1,
                speedColumn: -1,
                hasHeader: false,
                detected: false
            }
        };



        // 新增：日志数据
        let logData = {
            entries: [],
            maxEntries: 50
        };

        // 新增：通知数据
        let notifications = {
            active: [],
            maxNotifications: 5
        };

        // 新增：缓存时间戳
        let lastDownloadTimestamp = 0;
        const DOWNLOAD_CACHE_TIME = 2000; // 2秒缓存时间

        // 新增：确认对话框键盘事件处理器
        let dialogKeyHandler = null;

        document.addEventListener('DOMContentLoaded', () => {
            initDragDrop();
            initEvents();
            loadSavedToken();
            updateStats();
            addLog('系统启动', 'Vless节点生成工具已启动，欢迎使用！', 'info');
            initTabs();
            initAccordion();
            initHeaderToggle();

            // 初始化版本号显示（日期版号，短格式：YY.MM.DD.HH）
            try {
                const vEl = document.getElementById('versionText');
                const now = new Date();
                const yy = String(now.getFullYear()).slice(-2);
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const dd = String(now.getDate()).padStart(2, '0');
                const hh = String(now.getHours()).padStart(2, '0');
                vEl.textContent = `${yy}.${mm}.${dd}.${hh} - Vless节点生成工具`;
            } catch (e) {
                console.warn('不能设置版本号显示', e);
            }

            // 初始化粘贴输入框状态
            updateCSVInputState();

            // 初始化上传路径选择
            initUploadPathSelect();

            // 自动隐藏标题提示
            setTimeout(() => {
                const headerInfo = document.getElementById('headerInfo');
                if (headerInfo && !headerInfo.classList.contains('hidden')) {
                    headerInfo.classList.add('hidden');
                }
            }, 5000);
        });

        // 定时同步功能已移除

        // 通用上传函数，包含SHA重试逻辑
        async function uploadToGitHub(fileName, content, isBase64 = false, customMessage = '') {
            const token = document.getElementById('githubToken').value.trim();
            if (!token) {
                throw new Error('缺少GitHub Token，请先在GitHub配置中输入有效的令牌');
            }

            const repo = document.getElementById('githubRepo').value.trim();
            if (!repo) {
                throw new Error('GitHub仓库名称不能为空');
            }

            const branch = document.getElementById('githubBranch').value.trim() || 'main';

            // 记录原始操作
            const originalFileName = fileName;
            const isRetry = customMessage.includes('[重试]');

            // 步骤1: 尝试获取最新的SHA值
            let fileSha = null;
            let retryCount = 0;
            const maxRetries = 2;

            while (retryCount <= maxRetries) {
                try {
                    // 清除可能的缓存，使用时间戳
                    const timestamp = Date.now();
                    const checkUrl = `https://api.github.com/repos/${repo}/contents/${fileName}?ref=${branch}&t=${timestamp}`;

                    const checkRes = await fetch(checkUrl, {
                        headers: {
                            Authorization: `token ${token}`,
                            Accept: 'application/vnd.github.v3+json'
                        }
                    });

                    if (checkRes.ok) {
                        const json = await checkRes.json();
                        fileSha = json.sha;
                        console.log(`✅ 获取到 ${fileName} 的最新SHA: ${fileSha.substring(0, 8)}...`);
                        break; // 成功获取SHA，退出循环
                    } else if (checkRes.status === 404) {
                        console.log(`📄 ${fileName} 文件不存在，将创建新文件`);
                        fileSha = null;
                        break; // 文件不存在，退出循环
                    } else {
                        const err = await checkRes.json();
                        console.warn(`⚠️ 获取 ${fileName} SHA 失败(${checkRes.status}):`, err.message);

                        // 如果是403或429错误，可能是速率限制，等待后重试
                        if ((checkRes.status === 403 || checkRes.status === 429) && retryCount < maxRetries) {
                            retryCount++;
                            const waitTime = 2000 * retryCount;
                            console.log(`⏳ 等待 ${waitTime}ms 后重试...`);
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                            continue;
                        } else {
                            // 其他错误，抛出异常
                            throw new Error(`获取文件信息失败: ${err.message || checkRes.statusText}`);
                        }
                    }
                } catch (e) {
                    console.error(`❌ 获取 ${fileName} SHA 时出错:`, e);
                    if (retryCount < maxRetries) {
                        retryCount++;
                        const waitTime = 1000 * retryCount;
                        console.log(`⏳ 等待 ${waitTime}ms 后重试...`);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        continue;
                    } else {
                        throw e;
                    }
                }
            }

            // 步骤2: 准备上传数据
            const defaultMessage = isRetry
                ? `[重试]上传文件 ${fileName} - ${new Date().toLocaleString()}`
                : `上传文件 ${fileName} - ${new Date().toLocaleString()}`;

            const message = customMessage || defaultMessage;

            const body = {
                message: message,
                content: content,
                branch: branch
            };

            // 只有当文件已存在且有有效的SHA时才添加sha参数
            if (fileSha) {
                body.sha = fileSha;
            }

            // 步骤3: 执行上传
            retryCount = 0;
            while (retryCount <= maxRetries) {
                try {
                    const res = await fetch(`https://api.github.com/repos/${repo}/contents/${fileName}`, {
                        method: 'PUT',
                        headers: {
                            Authorization: `token ${token}`,
                            Accept: 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(body)
                    });

                    if (res.ok) {
                        const result = await res.json();
                        console.log(`✅ ${fileName} 上传成功，新SHA: ${result.content.sha.substring(0, 8)}...`);

                        // 生成链接，依据用户在高级配置中选择的链接类型（默认 GitHub Pages）
                        let githubIoUrl = `https://raw.githubusercontent.com/${repo}/${branch}/${fileName}`;
                        try {
                            const linkTypeEl = document.getElementById('fileLinkTypeSelect');
                            const linkType = linkTypeEl ? linkTypeEl.value : 'pages';
                            if (linkType === 'pages') {
                                const parts = repo.split('/');
                                if (parts.length >= 2) {
                                    const user = parts[0].toLowerCase();
                                    const repoName = parts[1];
                                    githubIoUrl = `https://${user}.github.io/${repoName}/${fileName}`;
                                }
                            } else if (linkType === 'raw') {
                                githubIoUrl = `https://raw.githubusercontent.com/${repo}/${branch}/${fileName}`;
                            }
                        } catch (e) {
                            // 回退到 raw 链接
                            githubIoUrl = `https://raw.githubusercontent.com/${repo}/${branch}/${fileName}`;
                        }

                        return {
                            success: true,
                            sha: result.content.sha,
                            isNew: !fileSha,
                            githubIoUrl: githubIoUrl
                        };
                    } else {
                        const err = await res.json();
                        console.error(`❌ ${fileName} 上传失败(${res.status}):`, err);

                        // 处理特定的错误类型
                        if (err.message && err.message.includes('does not match') && retryCount < maxRetries) {
                            // SHA不匹配，需要重新获取SHA并重试
                            console.log(`⚠️ ${fileName} SHA不匹配，重新获取SHA并重试...`);

                            // 强制重新获取SHA（跳过缓存）
                            const timestamp = Date.now();
                            const retryCheckUrl = `https://api.github.com/repos/${repo}/contents/${fileName}?ref=${branch}&t=${timestamp}&force=true`;

                            const retryCheckRes = await fetch(retryCheckUrl, {
                                headers: {
                                    Authorization: `token ${token}`,
                                    Accept: 'application/vnd.github.v3+json'
                                }
                            });

                            if (retryCheckRes.ok) {
                                const retryJson = await retryCheckRes.json();
                                body.sha = retryJson.sha; // 更新SHA
                                console.log(`✅ 重试获取到 ${fileName} 的新SHA: ${retryJson.sha.substring(0, 8)}...`);
                            } else {
                                // 如果获取失败，可能是文件已被删除，移除SHA尝试创建新文件
                                console.log(`📄 ${fileName} 可能已被删除，尝试创建新文件`);
                                delete body.sha;
                            }

                            // 更新消息，标记为重试
                            body.message = `[重试]${message}`;

                            retryCount++;
                            const waitTime = 1000 * retryCount;
                            console.log(`⏳ 等待 ${waitTime}ms 后重试上传...`);
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                            continue;
                        } else if ((res.status === 403 || res.status === 429) && retryCount < maxRetries) {
                            // GitHub API限制，等待后重试
                            retryCount++;
                            const waitTime = 3000 * retryCount;
                            console.log(`⏳ GitHub API限制，等待 ${waitTime}ms 后重试...`);
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                            continue;
                        } else {
                            throw new Error(`${fileName} 上传失败: ${err.message || res.statusText}`);
                        }
                    }
                } catch (e) {
                    console.error(`❌ ${fileName} 上传异常:`, e);
                    if (retryCount < maxRetries) {
                        retryCount++;
                        const waitTime = 2000 * retryCount;
                        console.log(`⏳ 等待 ${waitTime}ms 后重试上传...`);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        continue;
                    } else {
                        throw e;
                    }
                }
            }

            throw new Error(`${fileName} 上传失败，达到最大重试次数`);
        }

        function initEvents() {
            document.getElementById('fileInput').addEventListener('change', e => e.target.files[0] && handleFile(e.target.files[0]));
            document.getElementById('removeFileBtn').addEventListener('click', removeFile);
            document.getElementById('generateBtn').addEventListener('click', generateVless);
            document.getElementById('copyVlessBtn').addEventListener('click', () => copyText(data.vlessLinks.join('\n')));
            // 移除downloadVlessBtn事件监听，只保留downloadAllBtn
            document.getElementById('downloadAllBtn').addEventListener('click', downloadAll);
            document.getElementById('downloadSubBtn').addEventListener('click', () => {
                // 清除缓存，强制重新下载
                const now = Date.now();
                if (now - lastDownloadTimestamp > DOWNLOAD_CACHE_TIME) {
                    // 如果距离上次下载超过2秒，清除缓存
                    data.remoteNodes = [];
                    data.nodeSha = null;
                    data.plainSha = null;
                    data.optimalSha = null;
                    updateStats();
                }
                lastDownloadTimestamp = now;
                downloadRemote();
            });
            document.getElementById('mergeBtn').addEventListener('click', () => {
                validateAndMerge();
            });
            document.getElementById('syncBtn').addEventListener('click', oneClickSync);
            document.getElementById('copyMergedBtn').addEventListener('click', () => copyText(data.uniqueNodes.join('\n')));
            document.getElementById('copyMergedYamlBtn').addEventListener('click', () => copyText(data.mergedYamlContent));
            document.getElementById('downloadMergedYamlBtn').addEventListener('click', downloadMergedYaml);
            document.getElementById('copyLocalBase64Btn').addEventListener('click', () => copyText(data.localBase64Content));
            document.getElementById('copyLocalYamlBtn').addEventListener('click', () => copyText(data.localYamlContent));
            document.getElementById('downloadLocalYamlBtn').addEventListener('click', downloadLocalYaml);

            // 删除远程文件（及其 .yaml）功能实现
            async function deleteSingleGithubFile(filePath) {
                const token = document.getElementById('githubToken').value.trim();
                const repo = document.getElementById('githubRepo').value.trim();
                const branch = document.getElementById('githubBranch').value.trim() || 'main';
                if (!token) throw new Error('缺少GitHub Token，请先在GitHub配置中输入有效的令牌');
                if (!repo) throw new Error('缺少GitHub 仓库设置');
                if (!filePath) throw new Error('未指定要删除的文件名');

                // 先获取文件信息以获取 sha
                const metaRes = await fetch(`https://api.github.com/repos/${repo}/contents/${encodeURIComponent(filePath)}?ref=${branch}`, {
                    headers: {
                        Authorization: `token ${token}`,
                        Accept: 'application/vnd.github.v3+json'
                    }
                });
                if (metaRes.status === 404) {
                    return { found: false };
                }
                if (!metaRes.ok) {
                    const txt = await metaRes.text();
                    throw new Error(`获取文件信息失败: ${metaRes.status} ${txt}`);
                }
                const meta = await metaRes.json();
                const sha = meta.sha;

                const delRes = await fetch(`https://api.github.com/repos/${repo}/contents/${encodeURIComponent(filePath)}`, {
                    method: 'DELETE',
                    headers: {
                        Authorization: `token ${token}`,
                        Accept: 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message: `Delete ${filePath} via UI`, sha: sha, branch: branch })
                });
                if (!delRes.ok) {
                    const txt = await delRes.text();
                    throw new Error(`删除文件失败: ${delRes.status} ${txt}`);
                }
                return { found: true };
            }

            async function deleteGithubFiles(baseName) {
                if (!baseName) throw new Error('请输入要删除的文件名');
                const results = [];
                // 要删除的目标：baseName 以及 baseName.yaml
                const candidates = [baseName, `${baseName}.yaml`];
                for (const f of candidates) {
                    try {
                        const r = await deleteSingleGithubFile(f);
                        if (r.found) {
                            results.push({ file: f, deleted: true });
                        } else {
                            results.push({ file: f, deleted: false, reason: 'not found' });
                        }
                    } catch (e) {
                        results.push({ file: f, deleted: false, reason: e.message });
                    }
                }
                return results;
            }
            document.getElementById('copyAutoBase64Btn').addEventListener('click', () => copyText(data.autoBase64Content));
            document.getElementById('convertToBase64Btn').addEventListener('click', convertManualToBase64);
            document.getElementById('copyManualBase64Btn').addEventListener('click', () => copyText(data.manualBase64Content));
            document.getElementById('convertToYamlBtn').addEventListener('click', convertManualToYaml);
            document.getElementById('testParseBtn').addEventListener('click', testVlessParse);
            document.getElementById('copyYamlBtn').addEventListener('click', () => copyText(data.manualYamlContent));
            document.getElementById('downloadYamlBtn').addEventListener('click', downloadManualYaml);
            document.getElementById('uploadYamlBtn').addEventListener('click', uploadManualYaml);

            // 绑定：删除远程文件按钮
            const delBtn = document.getElementById('deleteRemoteFileBtn');
            if (delBtn) {
                delBtn.addEventListener('click', () => {
                    const base = document.getElementById('deleteFileName').value.trim();
                    if (!base) {
                        showNotification('错误', '请输入要删除的文件名（例如：OptimalNode）', 'error');
                        return;
                    }
                    showConfirmDialog('确认删除', `确定删除远程文件 ${base} 及 ${base}.yaml 吗？此操作不可恢复。`, async () => {
                        try {
                            showLoading(true, 'deleteRemoteFileBtn');
                            const res = await deleteGithubFiles(base);
                            const ok = res.filter(r => r.deleted).map(r => r.file);
                            const not = res.filter(r => !r.deleted).map(r => `${r.file}(${r.reason || '未找到'})`);
                            let msg = '';
                            if (ok.length) msg += `已删除：${ok.join(', ')}\n`;
                            if (not.length) msg += `未删除：${not.join(', ')}`;
                            showNotification('删除完成', msg, ok.length ? 'success' : 'warning');
                            addLog('删除远程文件', `删除结果: ${msg}`, ok.length ? 'success' : 'warning');
                        } catch (e) {
                            showNotification('删除失败', e.message || String(e), 'error');
                            addLog('删除远程文件', '删除失败: ' + (e.message || String(e)), 'error');
                        } finally {
                            showLoading(false, 'deleteRemoteFileBtn');
                        }
                    }, null, 'warning');
                });
            }

            // 原有的四个上传按钮 - 添加确认提示
            document.getElementById('uploadLocalBase64ToPathBtn').addEventListener('click', () => {
                validateAndUpload('uploadLocalBase64ToPath');
            });
            document.getElementById('uploadPlainNodesBtn').addEventListener('click', () => {
                validateAndUpload('uploadPlainNodes');
            });
            document.getElementById('uploadMergedBase64Btn').addEventListener('click', () => {
                validateAndUpload('uploadMergedBase64');
            });
            document.getElementById('uploadMergedOptimalBtn').addEventListener('click', () => {
                validateAndUpload('uploadMergedOptimal');
            });

            // 新增：上传合并订阅至指定路径按钮
            document.getElementById('uploadMergedToPathBtn').addEventListener('click', () => {
                validateAndUpload('uploadMergedToPath');
            });

            // 新增：下载路径选择事件
            document.getElementById('downloadUrlSelect').addEventListener('change', function () {
                const customInput = document.getElementById('customDownloadUrl');
                customInput.classList.toggle('show', this.value === 'custom');
                if (this.value !== 'custom') {
                    customInput.value = '';
                }
            });

            // 新增：上传路径选择事件
            document.getElementById('uploadPathSelect').addEventListener('change', function () {
                const customInput = document.getElementById('customUploadPath');
                customInput.classList.toggle('show', this.value === 'custom');
                if (this.value !== 'custom') {
                    customInput.value = '';
                }
            });

            // 新增：日志控制按钮事件
            document.getElementById('clearLogBtn').addEventListener('click', clearLog);
            document.getElementById('toggleLogBtn').addEventListener('click', toggleLog);

            // 新增：GitHub.io链接复制按钮事件
            document.getElementById('copyPlainNodesUrl').addEventListener('click', () => copyGithubUrl('plainNodesUrl'));
            document.getElementById('copyMergedBase64Url').addEventListener('click', () => copyGithubUrl('mergedBase64Url'));
            document.getElementById('copyMergedYamlUrl').addEventListener('click', () => copyGithubUrl('mergedYamlUrl'));
            document.getElementById('copyMergedOptimalUrl').addEventListener('click', () => copyGithubUrl('mergedOptimalUrl'));
            document.getElementById('copyLocalBase64Url').addEventListener('click', () => copyGithubUrl('localBase64Url'));
            document.getElementById('copyLocalYamlUrl').addEventListener('click', () => copyGithubUrl('localYamlUrl'));
            document.getElementById('copyMergedToPathUrl').addEventListener('click', () => copyGithubUrl('mergedToPathUrl'));
            document.getElementById('copyYamlConfigUrl').addEventListener('click', () => copyGithubUrl('yamlConfigUrl'));

            // 新增：代理工具下载按钮事件
            document.getElementById('downloadClashBtn').addEventListener('click', () => downloadProxyConfig('clash'));

            // 二维码显示（模态）控制：当点击外部按钮时会调用 showQR(url, label)
            document.addEventListener('click', (e) => {
                if (e.target && e.target.classList && e.target.classList.contains('show-qr-btn')) {
                    const url = e.target.getAttribute('data-url');
                    const label = e.target.getAttribute('data-label') || '';
                    showQR(url, label);
                }
            });

            // 修复：粘贴CSV内容生成节点的功能
            let csvTimer;
            document.getElementById('csvInput').addEventListener('input', () => {
                clearTimeout(csvTimer);
                // 当用户停止输入1秒后自动生成
                csvTimer = setTimeout(() => {
                    if (data.currentSource !== 'file') {
                        generateVless();
                    }
                }, 1000);
            });

            // 修复：当切换到粘贴标签页时，如果已有内容，自动生成
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('card-tab-btn') && e.target.getAttribute('data-tab') === 'paste-tab') {
                    const csvInput = document.getElementById('csvInput');
                    if (csvInput.value.trim() && data.currentSource !== 'file') {
                        generateVless();
                    }
                }
            });

            // 新增：手动Vless转IP:端口按钮事件
            document.getElementById('convertToIpPortBtn').addEventListener('click', convertManualToIpPort);
            document.getElementById('copyIpPortBtn').addEventListener('click', () => copyText(data.manualIpPortContent));
            document.getElementById('downloadIpPortBtn').addEventListener('click', downloadIpPortTxt);

            // 初始化手动转换工具标签页
            const manualTabNav = document.getElementById('manualTabNav');
            if (manualTabNav) {
                const tabButtons = manualTabNav.querySelectorAll('.card-tab-btn');
                tabButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        const cardBody = button.closest('.card-body');
                        const tabId = button.getAttribute('data-tab');

                        // 只在当前卡片内部切换
                        const allTabBtns = cardBody.querySelectorAll('.card-tab-btn');
                        const allTabContents = cardBody.querySelectorAll('.card-tab-content');

                        allTabBtns.forEach(btn => btn.classList.remove('active'));
                        allTabContents.forEach(content => content.classList.remove('active'));

                        button.classList.add('active');
                        const targetTab = cardBody.querySelector(`#${tabId}`);
                        if (targetTab) {
                            targetTab.classList.add('active');
                        }
                    });
                });
            }

            // 初始化自动同步控件（已移除）
        }

        // 清除远程缓存函数
        function clearRemoteCache() {
            data.remoteNodes = [];
            data.nodeSha = null;
            data.plainSha = null;
            data.optimalSha = null;
            data.locationSha = null;
            updateStats();
            console.log('🗑️ 远程缓存已清除');
            addLog('缓存清理', '远程节点缓存已清除', 'info');
        }

        // 明文订阅上传
        async function uploadPlainNodes() {
            showLoading(true, 'uploadPlainNodesBtn');
            try {
                if (data.uniqueNodes.length === 0) {
                    showNotification('错误', '请先合并节点，当前没有可上传的节点数据', 'error');
                    showLoading(false, 'uploadPlainNodesBtn');
                    return;
                }

                const plainNodeFile = document.getElementById('plainNodeFile').value.trim();
                const plainText = data.uniqueNodes.join('\n');

                // 使用通用上传函数
                const result = await uploadToGitHub(
                    plainNodeFile,
                    btoa(plainText),
                    false,
                    `上传合并明文订阅到 ${plainNodeFile} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                );

                // 标记缓存需要更新
                data.cache.needsUpdate = true;

                const message = result.isNew
                    ? `✅ 新建明文节点文件 ${plainNodeFile} 成功！包含 ${data.uniqueNodes.length} 个节点`
                    : `✅ 更新明文节点文件 ${plainNodeFile} 成功！包含 ${data.uniqueNodes.length} 个节点`;

                showNotification('上传成功', message, 'success');
                addLog('上传明文节点', `${message} (SHA: ${result.sha.substring(0, 8)}...)`, 'success');

                // 显示GitHub.io链接
                showGithubLink('plainNodesLink', 'plainNodesUrl', result.githubIoUrl);

                // 同时上传对应的YAML配置文件
                try {
                    const yamlFileName = plainNodeFile.replace(/\.[^/.]+$/, '') + '.yaml';
                    const yamlContent = data.mergedYamlContent;

                    const yamlResult = await uploadToGitHub(
                        yamlFileName,
                        utf8ToBase64(yamlContent),
                        false,
                        `上传合并YAML配置 ${yamlFileName} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                    );

                    const yamlMessage = yamlResult.isNew
                        ? `✅ 新建YAML配置文件 ${yamlFileName} 成功！`
                        : `✅ 更新YAML配置文件 ${yamlFileName} 成功！`;

                    showNotification('YAML上传成功', yamlMessage, 'success');
                    addLog('上传YAML配置', `${yamlMessage} (SHA: ${yamlResult.sha.substring(0, 8)}...)`, 'success');

                    // 显示YAML配置文件的GitHub.io链接（复用mergedYamlLink）
                    showGithubLink('mergedYamlLink', 'mergedYamlUrl', yamlResult.githubIoUrl);
                } catch (yamlError) {
                    console.warn('YAML文件上传失败，但节点文件已成功上传:', yamlError);
                    showNotification('YAML上传失败', '节点文件上传成功，但YAML配置文件上传失败: ' + yamlError.message, 'warning');
                }
            } catch (e) {
                showNotification('上传失败', '上传过程中发生错误: ' + e.message, 'error');
                addLog('上传明文节点', '上传失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'uploadPlainNodesBtn');
            }
        }

        // 初始化上传路径选择
        function initUploadPathSelect() {
            const uploadPathSelect = document.getElementById('uploadPathSelect');
            const customUploadPath = document.getElementById('customUploadPath');

            uploadPathSelect.addEventListener('change', function () {
                customUploadPath.classList.toggle('show', this.value === 'custom');
                if (this.value !== 'custom') {
                    customUploadPath.value = '';
                }
            });
        }

        // 更新CSV输入框状态
        function updateCSVInputState() {
            const csvInput = document.getElementById('csvInput');
            const pasteTabBtn = document.querySelector('.card-tab-btn[data-tab="paste-tab"]');

            if (data.currentSource === 'file') {
                // 有文件上传时，禁用粘贴输入框
                csvInput.disabled = true;
                csvInput.placeholder = "已上传文件，粘贴功能已禁用。请先移除文件。";
                pasteTabBtn.style.opacity = "0.6";
                pasteTabBtn.style.cursor = "not-allowed";
            } else {
                // 没有文件上传时，启用粘贴输入框
                csvInput.disabled = false;
                csvInput.placeholder = "支持多种格式，智能分割：\n1. 单行或多行格式（冒号,逗号，空格分隔）：\n2. 紧凑格式（一行多个）：\n3. 混合分隔符：\n4. 只有IP（使用默认端口）：";
                pasteTabBtn.style.opacity = "1";
                pasteTabBtn.style.cursor = "pointer";
            }
        }

        // 初始化标签页 - 修复：确保每个卡片的标签页独立
        function initTabs() {
            // 为每个卡片的标签页分别初始化
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => {
                const tabButtons = card.querySelectorAll('.card-tab-btn');
                if (tabButtons.length > 0) {
                    tabButtons.forEach(button => {
                        button.addEventListener('click', (e) => {
                            e.stopPropagation(); // 阻止事件冒泡
                            const cardBody = button.closest('.card-body');
                            const tabId = button.getAttribute('data-tab');

                            // 只在当前卡片内部切换
                            const allTabBtns = cardBody.querySelectorAll('.card-tab-btn');
                            const allTabContents = cardBody.querySelectorAll('.card-tab-content');

                            allTabBtns.forEach(btn => btn.classList.remove('active'));
                            allTabContents.forEach(content => content.classList.remove('active'));

                            button.classList.add('active');
                            const targetTab = cardBody.querySelector(`#${tabId}`);
                            if (targetTab) {
                                targetTab.classList.add('active');
                            }
                        });
                    });
                }
            });
        }

        // 初始化折叠面板
        function initAccordion() {
            const accordionToggle = document.getElementById('advancedConfigToggle');
            const accordionContent = document.getElementById('advancedConfigContent');

            accordionToggle.addEventListener('click', () => {
                accordionToggle.classList.toggle('active');
                accordionContent.classList.toggle('show');
            });
        }

        // 初始化标题显示/隐藏
        function initHeaderToggle() {
            const toggleBtn = document.getElementById('toggleHeaderBtn');
            const headerInfo = document.getElementById('headerInfo');

            toggleBtn.addEventListener('click', () => {
                if (headerInfo.classList.contains('hidden')) {
                    headerInfo.classList.remove('hidden');
                    toggleBtn.textContent = '隐藏';
                    showNotification('提示', '标题已显示', 'info');
                } else {
                    headerInfo.classList.add('hidden');
                    toggleBtn.textContent = '显示';
                    showNotification('提示', '标题已隐藏', 'info');
                }
            });
        }

        function initDragDrop() {
            const area = document.getElementById('dropArea');

            // 修复：确保拖拽功能正常工作
            ['dragenter', 'dragover'].forEach(e => {
                area.addEventListener(e, (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    area.classList.add('dragover');
                });
            });

            ['dragleave', 'drop'].forEach(e => {
                area.addEventListener(e, (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    area.classList.remove('dragover');
                });
            });

            // 修复：正确处理drop事件
            area.addEventListener('drop', e => {
                e.preventDefault();
                e.stopPropagation();
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    handleFile(files[0]);
                }
            });

            area.addEventListener('click', () => document.getElementById('fileInput').click());
        }

        function handleFile(file) {
            if (!/\.(csv|txt)$/i.test(file.name)) {
                showNotification('文件错误', '请上传CSV或TXT文件，当前文件格式不支持', 'error');
                addLog('文件操作', `文件格式错误: ${file.name}`, 'error');
                return;
            }

            // 修复：确保文件被正确设置到fileInput元素
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            document.getElementById('fileInput').files = dataTransfer.files;

            const reader = new FileReader();
            reader.onload = e => {
                data.currentSource = 'file';
                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileSize').textContent = formatSize(file.size);
                document.getElementById('fileInfo').classList.add('show');
                document.getElementById('csvInput').value = '';
                updateSourceBadge();
                // 更新CSV输入框状态
                updateCSVInputState();

                // 文件上传后自动进行列检测
                autoDetectCSVColumns();

                // 修复：文件上传后自动生成节点
                setTimeout(() => {
                    generateVless();
                }, 100);

                addLog('文件操作', `成功上传文件: ${file.name}`, 'success');
            };
            reader.onerror = e => {
                showNotification('文件读取失败', '无法读取文件内容，请检查文件是否损坏或重新上传', 'error');
                addLog('文件操作', `文件读取失败: ${file.name} - ${e.message}`, 'error');
            };
            reader.readAsText(file);
        }

        function removeFile() {
            data.currentSource = 'none';
            document.getElementById('fileInfo').classList.remove('show');
            document.getElementById('fileInput').value = '';
            document.getElementById('fileName').textContent = '';
            document.getElementById('fileSize').textContent = '';
            updateSourceBadge();
            // 更新CSV输入框状态
            updateCSVInputState();

            // 清除检测结果
            document.getElementById('columnDetectionResult').style.display = 'none';

            addLog('文件操作', '已移除上传的文件', 'info');

            // 清空生成结果
            data.vlessLinks = [];
            data.localBase64Content = '';
            data.localYamlContent = '';
            data.autoBase64Content = '';
            data.mergedYamlContent = '';
            displayVlessLinks();
            document.getElementById('localBase64Output').textContent = 'Base64订阅内容将在这里显示...';
            document.getElementById('localBase64Output').classList.add('empty');
            document.getElementById('localYamlOutput').textContent = '本地YAML配置将在这里显示...';
            document.getElementById('localYamlOutput').classList.add('empty');
            document.getElementById('autoBase64Output').textContent = '合并去重后将自动生成Base64订阅内容...';
            document.getElementById('autoBase64Output').classList.add('empty');
            document.getElementById('mergedYamlOutput').textContent = '合并后的YAML配置将在这里显示...';
            document.getElementById('mergedYamlOutput').classList.add('empty');
            updateStats();
        }

        function updateSourceBadge() {
            const badge = document.getElementById('sourceBadge');
            badge.textContent = data.currentSource === 'file' ? '已上传文件' : '粘贴内容';
        }

        // 新增：智能检测CSV列功能 - 修复：准确检测速度列和端口列
        // 新增：智能检测CSV列功能 - 完整修复版
        function autoDetectCSVColumns() {
            const fileInput = document.getElementById('fileInput');
            if (!fileInput.files || fileInput.files.length === 0) {
                showNotification('检测失败', '请先上传CSV文件', 'warning');
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function (e) {
                const text = e.target.result;
                const lines = text.split(/\r?\n/).filter(line => line.trim());

                if (lines.length === 0) {
                    showNotification('检测失败', 'CSV文件为空', 'error');
                    return;
                }

                // 尝试解析CSV内容
                const firstFewLines = lines.slice(0, 15); // 分析前15行以获得更多样本
                const rows = [];

                for (let line of firstFewLines) {
                    try {
                        const row = parseCSVLine(line);
                        if (row.length > 0) {
                            rows.push(row);
                        }
                    } catch (e) {
                        console.warn('解析CSV行失败:', e);
                    }
                }

                if (rows.length === 0) {
                    showNotification('检测失败', '无法解析CSV文件格式', 'error');
                    return;
                }

                // 检测是否有标题行
                let hasHeader = false;
                const firstRow = rows[0];
                const secondRow = rows.length > 1 ? rows[1] : [];

                // 检查第一行是否包含常见的标题关键词
                const headerKeywords = [
                    'host', 'ip', 'address', '服务器', 'ip地址', 'IP 地址',
                    'port', '端口',
                    'city', '城市', '地区', 'location',
                    'country', '国家', 'country_code', 'nation', 'country_name',
                    'region', '区域', '州', '省', 'area', 'code', '地区码',
                    'speed', '速度', '下载速度', '带宽', 'download', 'mb/s', 'mb', 'mbit',
                    'delay', '延迟', '平均延迟', 'ping', 'time', 'ms' // 延迟相关关键词
                ];

                let headerMatchCount = 0;
                let firstRowIsLikelyData = false;

                // 检查第一行是否是数据（包含IP或数字）
                for (let cell of firstRow) {
                    const cellStr = cell.toString().trim();
                    if (isValidIP(cellStr) || /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(cellStr)) {
                        firstRowIsLikelyData = true;
                        break;
                    }
                    if (/^\d{1,5}$/.test(cellStr) && parseInt(cellStr) >= 1 && parseInt(cellStr) <= 65535) {
                        firstRowIsLikelyData = true;
                        break;
                    }
                }

                // 检查第一行是否包含标题关键词
                for (let cell of firstRow) {
                    const lowerCell = cell.toString().toLowerCase().trim();
                    for (let keyword of headerKeywords) {
                        if (lowerCell.includes(keyword.toLowerCase())) {
                            headerMatchCount++;
                            break;
                        }
                    }
                }

                // 判断是否有标题行
                hasHeader = headerMatchCount >= 2 && !firstRowIsLikelyData;

                // 确定数据起始行
                const dataStartIndex = hasHeader ? 1 : 0;
                const dataRows = rows.slice(dataStartIndex).slice(0, 10); // 只分析前10行数据

                if (dataRows.length === 0) {
                    showNotification('检测失败', 'CSV文件中没有数据行', 'error');
                    return;
                }

                // 检测各列
                const columnCount = Math.max(...dataRows.map(row => row.length));
                const columnStats = new Array(columnCount).fill().map(() => ({
                    ipCount: 0,
                    portCount: 0,
                    speedCount: 0,
                    delayCount: 0,
                    textCount: 0,
                    numericCount: 0,
                    total: 0,
                    values: [] // 存储实际值用于分析
                }));

                // 收集列统计信息
                for (let row of dataRows) {
                    for (let i = 0; i < row.length; i++) {
                        const cell = row[i].toString().trim();
                        columnStats[i].total++;
                        columnStats[i].values.push(cell);

                        if (isValidIP(cell)) {
                            columnStats[i].ipCount++;
                        }
                        // 检测端口（1-65535的整数）
                        else if (/^\d{1,5}$/.test(cell)) {
                            const num = parseInt(cell);
                            if (num >= 1 && num <= 65535) {
                                columnStats[i].portCount++;
                            }
                        }
                        // 检测速度（包含数字和速度单位）
                        else if (isSpeedValue(cell)) {
                            columnStats[i].speedCount++;
                        }
                        // 检测延迟（包含数字和时间单位）
                        else if (isDelayValue(cell)) {
                            columnStats[i].delayCount++;
                        }
                        // 检测数字（包含小数）
                        else if (/^-?\d+(\.\d+)?$/.test(cell)) {
                            columnStats[i].numericCount++;
                        }
                        // 文本内容
                        else if (cell.length > 0) {
                            columnStats[i].textCount++;
                        }
                    }
                }

                // 检测IP列
                let ipColumn = 0;
                let maxIpScore = 0;
                for (let i = 0; i < columnStats.length; i++) {
                    const ipScore = columnStats[i].ipCount / Math.max(1, columnStats[i].total);
                    if (ipScore > maxIpScore) {
                        maxIpScore = ipScore;
                        ipColumn = i;
                    }
                }

                // 检测端口列 - 改进算法
                let portColumn = -1;
                let maxPortScore = 0;

                // 方法1：基于标题检测
                if (hasHeader) {
                    for (let i = 0; i < firstRow.length; i++) {
                        const header = firstRow[i].toString().toLowerCase();
                        if (header.includes('port') || header.includes('端口')) {
                            portColumn = i;
                            break;
                        }
                    }
                }

                // 方法2：基于数据模式检测
                if (portColumn === -1) {
                    for (let i = 0; i < columnStats.length; i++) {
                        if (i === ipColumn) continue;

                        // 计算端口得分
                        const portScore = columnStats[i].portCount / Math.max(1, columnStats[i].total);

                        // 检查是否是常见端口
                        const commonPorts = [80, 443, 8080, 8443, 22, 21, 25, 53];
                        let commonPortMatches = 0;
                        for (const value of columnStats[i].values) {
                            if (commonPorts.includes(parseInt(value))) {
                                commonPortMatches++;
                            }
                        }
                        const commonPortScore = commonPortMatches / Math.max(1, columnStats[i].total);

                        // 综合得分
                        const totalScore = portScore * 0.7 + commonPortScore * 0.3;

                        if (totalScore > maxPortScore && totalScore > 0.4) { // 阈值提高到40%
                            maxPortScore = totalScore;
                            portColumn = i;
                        }
                    }
                }

                // 检测速度列 - 重点修复G列（索引6）检测
                let speedColumn = -1;
                let maxSpeedScore = 0;

                // 特别检查G列（第7列，索引6）
                if (columnStats.length > 6) {
                    const gColumn = 6;
                    const gColumnValues = columnStats[gColumn].values;
                    let gSpeedScore = 0;

                    for (const value of gColumnValues) {
                        if (isSpeedValue(value)) {
                            gSpeedScore++;
                        }
                    }

                    if (gSpeedScore / Math.max(1, gColumnValues.length) > 0.5) {
                        speedColumn = gColumn;
                        maxSpeedScore = gSpeedScore / gColumnValues.length;
                    }
                }

                // 如果G列不是速度列，继续正常检测
                if (speedColumn === -1) {
                    for (let i = 0; i < columnStats.length; i++) {
                        if (i === ipColumn || i === portColumn) continue;

                        // 基于标题检测
                        if (hasHeader) {
                            const header = firstRow[i].toString().toLowerCase();
                            const speedKeywords = ['speed', '速度', 'download', 'bandwidth', '带宽', 'mb/s', 'mb', 'mbit', 'mbit/s'];
                            for (const keyword of speedKeywords) {
                                if (header.includes(keyword)) {
                                    speedColumn = i;
                                    break;
                                }
                            }
                            if (speedColumn !== -1) break;
                        }

                        // 基于数据检测
                        const speedScore = columnStats[i].speedCount / Math.max(1, columnStats[i].total);
                        if (speedScore > maxSpeedScore && speedScore > 0.3) {
                            maxSpeedScore = speedScore;
                            speedColumn = i;
                        }
                    }
                }

                // 检测延迟列（防止误判）
                let delayColumn = -1;
                let maxDelayScore = 0;
                for (let i = 0; i < columnStats.length; i++) {
                    if (i === ipColumn || i === portColumn || i === speedColumn) continue;

                    if (hasHeader) {
                        const header = firstRow[i].toString().toLowerCase();
                        if (header.includes('delay') || header.includes('延迟') ||
                            header.includes('ping') || header.includes('ms') ||
                            header.includes('time')) {
                            delayColumn = i;
                            break;
                        }
                    }

                    const delayScore = columnStats[i].delayCount / Math.max(1, columnStats[i].total);
                    if (delayScore > maxDelayScore && delayScore > 0.3) {
                        maxDelayScore = delayScore;
                        delayColumn = i;
                    }
                }

                // 检测城市列
                let cityColumn = -1;
                for (let i = 0; i < columnStats.length; i++) {
                    if (i === ipColumn || i === portColumn || i === speedColumn || i === delayColumn) continue;

                    if (hasHeader) {
                        const header = firstRow[i].toString().toLowerCase();
                        if (header.includes('city') || header.includes('城市') ||
                            header.includes('地区') || header.includes('location')) {
                            cityColumn = i;
                            break;
                        }
                    }

                    // 文本列可能是城市
                    if (columnStats[i].textCount / Math.max(1, columnStats[i].total) > 0.7) {
                        cityColumn = i;
                    }
                }

                // 检测国家列
                let countryColumn = -1;
                for (let i = 0; i < columnStats.length; i++) {
                    if (i === ipColumn || i === portColumn || i === speedColumn ||
                        i === delayColumn || i === cityColumn) continue;

                    if (hasHeader) {
                        const header = firstRow[i].toString().toLowerCase();
                        if (header.includes('country') || header.includes('国家') ||
                            header.includes('nation') || header.includes('country_code') || header.includes('country_name')) {
                            countryColumn = i;
                            break;
                        }
                    }
                }

                // 检测地区码列
                let regionColumn = -1;
                for (let i = 0; i < columnStats.length; i++) {
                    if (i === ipColumn || i === portColumn || i === speedColumn ||
                        i === delayColumn || i === cityColumn || i === countryColumn) continue;

                    if (hasHeader) {
                        const header = firstRow[i].toString().toLowerCase();
                        if (header.includes('region') || header.includes('区域') ||
                            header.includes('州') || header.includes('省') ||
                            header.includes('area') || header.includes('code') || header.includes('地区码')) {
                            regionColumn = i;
                            break;
                        }
                    }
                }

                // 保存检测结果
                data.csvColumnDetection = {
                    ipColumn: ipColumn,
                    portColumn: portColumn,
                    cityColumn: cityColumn,
                    countryColumn: countryColumn,
                    regionColumn: regionColumn,
                    speedColumn: speedColumn,
                    delayColumn: delayColumn,
                    hasHeader: hasHeader,
                    detected: true,
                    columnStats: columnStats
                };

                // 更新UI
                updateColumnDetectionUI();

                // 应用检测结果到表单
                applyDetectedColumns();

                // 根据检测质量设置状态类
                const resultDiv = document.getElementById('columnDetectionResult');
                let detectionQuality = 'success';

                // 判断检测质量
                if (portColumn === -1 || speedColumn === -1) {
                    detectionQuality = 'warning';
                }

                // 移除所有状态类
                resultDiv.classList.remove('success', 'warning');
                // 添加当前状态类
                resultDiv.classList.add(detectionQuality);

                const summary = `检测到${columnCount}列，${hasHeader ? '有标题行' : '无标题行'}，IP列: ${ipColumn + 1}(${String.fromCharCode(65 + ipColumn)})，${portColumn !== -1 ? `端口列: ${portColumn + 1}(${String.fromCharCode(65 + portColumn)})` : '未检测到端口列'}`;
                showNotification('检测完成', summary, 'success');
                addLog('CSV列检测', summary, 'success');
            };

            reader.onerror = function (e) {
                showNotification('检测失败', '无法读取文件内容', 'error');
                addLog('CSV列检测', '文件读取失败', 'error');
            };

            reader.readAsText(file);
        }


        // 新增：判断是否为速度值
        // 新增：判断是否为速度值
        function isSpeedValue(value) {
            if (!value || typeof value !== 'string') return false;

            const normalized = value.toLowerCase().trim();

            // 匹配速度模式
            const speedPatterns = [
                /^(\d+(\.\d+)?)\s*(mb\/s|mbps|mbit\/s|mbit|mb)$/i,
                /^(\d+(\.\d+)?)\s*(gb\/s|gbps|gbit\/s|gbit|gb)$/i,
                /^(\d+(\.\d+)?)\s*(kb\/s|kbps|kbit\/s|kbit|kb)$/i,
                /^(\d+(\.\d+)?)\s*(m\/s)$/i,
                /^(\d+(\.\d+)?)\s*速度$/i,
                /^下载速度\s*[:：]?\s*(\d+(\.\d+)?)/i,
                /^带宽\s*[:：]?\s*(\d+(\.\d+)?)/i
            ];

            for (const pattern of speedPatterns) {
                if (pattern.test(normalized)) {
                    return true;
                }
            }

            // 检查是否包含速度单位
            const speedUnits = ['mb/s', 'mbps', 'mbit/s', 'gb/s', 'gbps', 'gbit/s', 'kb/s', 'kbps', 'm/s', '速度', '带宽'];
            for (const unit of speedUnits) {
                if (normalized.includes(unit)) {
                    return true;
                }
            }

            return false;
        }

        // 新增：判断是否为延迟值
        function isDelayValue(value) {
            if (!value || typeof value !== 'string') return false;

            const normalized = value.toLowerCase().trim();

            // 匹配延迟模式
            const delayPatterns = [
                /^(\d+(\.\d+)?)\s*(ms|毫秒)$/i,
                /^(\d+(\.\d+)?)\s*(s|秒)$/i,
                /^延迟\s*[:：]?\s*(\d+(\.\d+)?)/i,
                /^ping\s*[:：]?\s*(\d+(\.\d+)?)/i,
                /^(\d+(\.\d+)?)\s*ms$/i
            ];

            for (const pattern of delayPatterns) {
                if (pattern.test(normalized)) {
                    return true;
                }
            }

            // 检查是否包含延迟单位
            const delayUnits = ['ms', '毫秒', '延迟', 'ping', 'latency'];
            for (const unit of delayUnits) {
                if (normalized.includes(unit)) {
                    return true;
                }
            }

            return false;
        }

        // 新增：判断是否为延迟值
        function isDelayValue(value) {
            if (!value || typeof value !== 'string') return false;

            const normalized = value.toLowerCase().trim();

            // 匹配延迟模式
            const delayPatterns = [
                /^(\d+(\.\d+)?)\s*(ms|毫秒)$/i,
                /^(\d+(\.\d+)?)\s*(s|秒)$/i,
                /^延迟\s*[:：]?\s*(\d+(\.\d+)?)/i,
                /^ping\s*[:：]?\s*(\d+(\.\d+)?)/i,
                /^(\d+(\.\d+)?)\s*ms$/i
            ];

            for (const pattern of delayPatterns) {
                if (pattern.test(normalized)) {
                    return true;
                }
            }

            // 检查是否包含延迟单位
            const delayUnits = ['ms', '毫秒', '延迟', 'ping', 'latency'];
            for (const unit of delayUnits) {
                if (normalized.includes(unit)) {
                    return true;
                }
            }

            return false;
        }

        // 更新列检测结果显示 - 优化样式
        // 更新列检测结果显示 - 优化样式和逻辑
        // 更新列检测结果显示 - 优化样式和逻辑
        function updateColumnDetectionUI() {
            const detection = data.csvColumnDetection;
            const resultDiv = document.getElementById('columnDetectionResult');
            const summarySpan = document.getElementById('detectionSummary');
            const detailsDiv = document.getElementById('detectionDetails');

            if (detection.detected) {
                resultDiv.style.display = 'block';

                // 构建检测结果摘要（更紧凑的格式）
                let summaryParts = [];
                summaryParts.push(`IP列: ${detection.ipColumn + 1}(${String.fromCharCode(65 + detection.ipColumn)})`);

                if (detection.portColumn !== -1) {
                    summaryParts.push(`端口列: ${detection.portColumn + 1}(${String.fromCharCode(65 + detection.portColumn)})`);
                }

                if (detection.speedColumn !== -1) {
                    summaryParts.push(`速度列: ${detection.speedColumn + 1}(${String.fromCharCode(65 + detection.speedColumn)})`);
                }

                if (detection.cityColumn !== -1) {
                    summaryParts.push(`城市列: ${detection.cityColumn + 1}(${String.fromCharCode(65 + detection.cityColumn)})`);
                }

                summarySpan.textContent = summaryParts.join(' | ');

                // 构建详细说明 - 只在有需要说明的内容时才显示
                let detailsContent = '';
                let hasImportantNotes = false;

                if (detection.portColumn === -1) {
                    detailsContent += '• 未检测到端口列，将使用默认端口443<br>';
                    hasImportantNotes = true;
                }

                if (detection.speedColumn === -1) {
                    detailsContent += '• 未检测到速度列，别名中将不包含速度信息<br>';
                    hasImportantNotes = true;
                }

                if (detection.speedColumn !== -1) {
                    const speedColStats = detection.columnStats[detection.speedColumn];
                    const confidence = Math.round((speedColStats.speedCount / Math.max(1, speedColStats.total)) * 100);
                    if (confidence < 70) {
                        detailsContent += `• 速度列检测置信度较低(${confidence}%)，可能需要手动调整<br>`;
                        hasImportantNotes = true;
                    }
                }

                if (detection.portColumn !== -1) {
                    const portColStats = detection.columnStats[detection.portColumn];
                    const confidence = Math.round((portColStats.portCount / Math.max(1, portColStats.total)) * 100);
                    if (confidence < 70) {
                        detailsContent += `• 端口列检测置信度较低(${confidence}%)，可能需要手动调整<br>`;
                        hasImportantNotes = true;
                    }
                }

                // 如果有重要说明才显示，否则不显示说明部分
                if (hasImportantNotes) {
                    detailsDiv.innerHTML = '<strong>检测说明：</strong><br>' + detailsContent;
                    detailsDiv.style.display = 'block';
                } else {
                    detailsDiv.style.display = 'none';
                }
            }
        }
        // 应用检测结果到表单
        function applyDetectedColumns() {
            const detection = data.csvColumnDetection;
            if (!detection.detected) return;

            document.getElementById('ipColumn').value = detection.ipColumn;
            document.getElementById('portColumn').value = detection.portColumn;
            document.getElementById('cityColumn').value = detection.cityColumn;
            document.getElementById('countryColumn').value = detection.countryColumn;
            document.getElementById('regionColumn').value = detection.regionColumn;
            document.getElementById('speedColumn').value = detection.speedColumn;

            // 将检测结果反映在输入框上：加上 detected / not-detected 类
            const setDetectionClass = (id, colIndex) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.classList.remove('detected', 'not-detected');
                if (colIndex === -1) {
                    el.classList.add('not-detected');
                } else {
                    el.classList.add('detected');
                }
            };

            setDetectionClass('ipColumn', detection.ipColumn);
            setDetectionClass('portColumn', detection.portColumn);
            setDetectionClass('cityColumn', detection.cityColumn);
            setDetectionClass('countryColumn', detection.countryColumn);
            setDetectionClass('regionColumn', detection.regionColumn);
            setDetectionClass('speedColumn', detection.speedColumn);
        }

        async function generateVless() {
            showLoading(true, 'generateBtn');
            try {
                const config = getConfig();

                let text = '';
                if (data.currentSource === 'file') {
                    const fileInput = document.getElementById('fileInput');
                    if (!fileInput.files || fileInput.files.length === 0) {
                        showNotification('生成节点失败', '请先上传CSV文件或粘贴内容', 'error');
                        showLoading(false, 'generateBtn');
                        return;
                    }
                    const file = fileInput.files[0];
                    text = await readFile(file);
                } else {
                    text = document.getElementById('csvInput').value.trim();
                    if (!text) {
                        showNotification('生成节点失败', '请提供CSV数据，可以上传文件或粘贴内容', 'error');
                        showLoading(false, 'generateBtn');
                        return;
                    }
                }

                data.vlessLinks = parseAndGenerate(text, config);
                data.stats.local = data.vlessLinks.length;
                data.cache.lastLocalGeneration = Date.now();

                // 自动生成本地Base64
                if (data.vlessLinks.length > 0) {
                    data.localBase64Content = btoa(data.vlessLinks.join('\n'));
                    // 生成对应的本地YAML内容
                    data.localYamlContent = generateClashYAML(data.vlessLinks);
                    document.getElementById('localBase64Output').textContent = data.localBase64Content;
                    document.getElementById('localBase64Output').classList.remove('empty');
                    document.getElementById('localYamlOutput').textContent = data.localYamlContent;
                    document.getElementById('localYamlOutput').classList.remove('empty');
                }

                displayVlessLinks();
                updateStats();

                // 智能检查：如果已有远程节点缓存，自动提示合并
                if (data.remoteNodes.length > 0 || data.cache.remoteNodes.length > 0) {
                    // 如果远程节点为空但缓存中有数据，恢复缓存
                    if (data.remoteNodes.length === 0 && data.cache.remoteNodes.length > 0) {
                        data.remoteNodes = [...data.cache.remoteNodes];
                        data.stats.remote = data.remoteNodes.length;
                        updateStats();
                    }

                    // 显示合并提示
                    setTimeout(() => {
                        showNotification('提示', `已生成 ${data.vlessLinks.length} 个本地节点，检测到 ${data.remoteNodes.length} 个远程节点，点击"合并节点"按钮进行合并`, 'info');
                    }, 500);
                }

                showNotification('节点生成成功', `成功生成 ${data.vlessLinks.length} 个Vless节点，并自动生成Base64订阅`, 'success');
                addLog('生成节点', `成功生成 ${data.vlessLinks.length} 个Vless节点`, 'success');
            } catch (e) {
                showNotification('节点生成失败', '生成过程中发生错误: ' + e.message, 'error');
                addLog('生成节点', '生成失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'generateBtn');
            }
        }

        function getConfig() {
            return {
                uuid: "471a8e64-7b21-4703-b1d1-45a221098459",
                host: document.getElementById('host').value.trim() || "knny.dpdns.org",
                sni: document.getElementById('sni').value.trim() || "knny.dpdns.org",
                fp: document.getElementById('fp').value.trim() || "chrome",
                force443: document.getElementById('forcePort443').checked,
                defaultPort: parseInt(document.getElementById('defaultPort').value) || 443,
                prefix: document.getElementById('remarksPrefix').value.trim() || '自选',
                autoLoc: document.getElementById('autoLocation').checked,
                useCsvInfo: document.getElementById('useCsvInfo').checked,
                ipColumn: parseInt(document.getElementById('ipColumn').value) || 0,
                portColumn: parseInt(document.getElementById('portColumn').value) || -1,
                cityColumn: parseInt(document.getElementById('cityColumn').value) || -1,
                countryColumn: parseInt(document.getElementById('countryColumn').value) || -1,
                regionColumn: parseInt(document.getElementById('regionColumn').value) || -1,
                speedColumn: parseInt(document.getElementById('speedColumn').value) || -1
            };
        }

        function parseAndGenerate(text, config) {
            // 如果是文件上传的CSV，尝试解析完整CSV
            if (data.currentSource === 'file') {
                return parseCSVFile(text, config);
            } else {
                // 如果是粘贴内容，使用智能分割
                return parsePasteText(text, config);
            }
        }

        // 解析CSV文件 - 修复别名生成逻辑
        // 解析CSV文件 - 修复别名生成逻辑，按照需求1生成别名
        function parseCSVFile(text, config) {
            const nodes = [];
            const regionGroups = {};
            const lines = text.split(/\r?\n/).filter(line => line.trim());

            if (lines.length === 0) return [];

            // 检查是否有标题行
            let hasHeader = data.csvColumnDetection.detected ? data.csvColumnDetection.hasHeader : false;
            if (!data.csvColumnDetection.detected) {
                // 如果没有检测过，进行简单检测
                const firstLine = lines[0].toLowerCase();
                hasHeader = firstLine.includes('ip') || firstLine.includes('host') ||
                    firstLine.includes('port') || firstLine.includes('地址') ||
                    firstLine.includes('端口');
            }

            let startIndex = hasHeader ? 1 : 0;

            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                try {
                    const row = parseCSVLine(line);

                    // 获取IP和端口
                    let ip = '';
                    let port = config.defaultPort;

                    // 从指定列获取IP
                    if (config.ipColumn >= 0 && config.ipColumn < row.length) {
                        ip = row[config.ipColumn].trim();
                        // 如果IP包含端口，分割出来
                        if (ip.includes(':')) {
                            const parts = ip.split(':');
                            ip = parts[0];
                            if (parts.length > 1) {
                                const portStr = parts[1];
                                if (portStr && /^\d{1,5}$/.test(portStr)) {
                                    port = parseInt(portStr) || config.defaultPort;
                                }
                            }
                        }
                    }

                    // 从指定列获取端口
                    if (config.portColumn >= 0 && config.portColumn < row.length) {
                        const portStr = row[config.portColumn].trim();
                        if (portStr && /^\d{1,5}$/.test(portStr)) {
                            const parsedPort = parseInt(portStr);
                            if (parsedPort >= 1 && parsedPort <= 65535) {
                                port = parsedPort;
                            }
                        }
                    }

                    // 验证IP有效性
                    if (!isValidIP(ip)) {
                        continue;
                    }

                    // 强制使用443端口（如果勾选了此选项）
                    if (config.force443) {
                        port = 443;
                    }

                    // 获取CSV中的信息用于生成别名
                    let city = '';
                    let country = '';
                    let region = '';
                    let speed = '';

                    if (config.cityColumn >= 0 && config.cityColumn < row.length) {
                        city = row[config.cityColumn].trim();
                    }

                    if (config.countryColumn >= 0 && config.countryColumn < row.length) {
                        country = row[config.countryColumn].trim();
                    }

                    if (config.regionColumn >= 0 && config.regionColumn < row.length) {
                        region = row[config.regionColumn].trim();
                    }

                    if (config.speedColumn >= 0 && config.speedColumn < row.length) {
                        speed = row[config.speedColumn].trim();
                        // 提取速度数值
                        const speedMatch = speed.match(/(\d+(\.\d+)?)/);
                        if (speedMatch) {
                            speed = `${speedMatch[1]}MB/s`;
                        }
                    }

                    // 转换地区码为中文名称
                    let chineseRegion = '';
                    if (region && region.trim()) {
                        const regionUpper = region.trim().toUpperCase();
                        if (regionCodeToChinese[regionUpper]) {
                            chineseRegion = regionCodeToChinese[regionUpper];
                        }
                    }

                    // 转换城市名为中文名称
                    let chineseCity = '';
                    if (city && city.trim()) {
                        const cityUpper = city.trim().toUpperCase();
                        if (regionCodeToChinese[cityUpper]) {
                            chineseCity = regionCodeToChinese[cityUpper];
                        } else {
                            chineseCity = city;
                        }
                    }

                    // 转换国家名为中文名称
                    let chineseCountry = '';
                    if (country && country.trim()) {
                        const countryName = country.trim();
                        if (countryNameToChinese[countryName]) {
                            chineseCountry = countryNameToChinese[countryName];
                        } else {
                            chineseCountry = country;
                        }
                    }

                    // 确定地区名用于分组和序号
                    let regionNameForGroup = '';

                    // 优先使用CSV信息（如果用户勾选了使用CSV信息）
                    if (config.useCsvInfo) {
                        if (chineseRegion) {
                            regionNameForGroup = chineseRegion;
                        } else if (chineseCity) {
                            regionNameForGroup = chineseCity;
                        } else if (chineseCountry) {
                            regionNameForGroup = chineseCountry;
                        }
                    }

                    // 如果没有从CSV获取到地区信息，使用IP检测
                    if (!regionNameForGroup) {
                        const detectedLocation = getLocation(ip);
                        regionNameForGroup = detectedLocation !== '未知' ? detectedLocation : config.prefix;
                    }

                    // 初始化地区组
                    if (!regionGroups[regionNameForGroup]) {
                        regionGroups[regionNameForGroup] = {
                            nodes: [],
                            counter: 1
                        };
                    }

                    // 为当前节点生成序号
                    const sequence = regionGroups[regionNameForGroup].counter.toString().padStart(2, '0');

                    // 生成别名部分数组
                    const aliasParts = [];

                    // 1. 地区名+序号（如：圣何塞01）
                    aliasParts.push(`${regionNameForGroup}${sequence}`);

                    // 2. 下载速度（如果有）
                    if (speed) {
                        aliasParts.push(speed);
                    }

                    // 3. 端口
                    aliasParts.push(port.toString());

                    // 4. 国家（如果有）
                    if (chineseCountry) {
                        aliasParts.push(chineseCountry);
                    }

                    // 5. IP地址
                    aliasParts.push(ip);

                    // 用"-"连接所有部分
                    const remark = aliasParts.join('-');

                    // 保存节点信息
                    regionGroups[regionNameForGroup].nodes.push({
                        ip: ip,
                        port: port,
                        remark: remark,
                        config: config
                    });

                    // 增加计数器
                    regionGroups[regionNameForGroup].counter++;
                } catch (e) {
                    console.warn(`解析CSV行失败: ${line}`, e);
                }
            }

            // 生成所有节点
            Object.keys(regionGroups).forEach(regionName => {
                regionGroups[regionName].nodes.forEach(node => {
                    nodes.push(generateLink(node.ip, node.port, node.config, node.remark));
                });
            });

            console.log(`CSV解析完成：生成 ${nodes.length} 个节点，按 ${Object.keys(regionGroups).length} 个地区分组`);
            return nodes;
        }

        // 新增：从CSV信息生成别名（根据需求1）
        function generateRemarkFromCSV(ip, port, city, country, region, speed, config) {
            // 如果不使用CSV信息，使用默认方式
            if (!config.useCsvInfo) {
                const location = getLocation(ip);
                const regionKey = location !== '未知' ? location : config.prefix;
                return {
                    remark: `${location}-${port}-${ip}`,
                    regionKey: regionKey
                };
            }

            // 转换地区码为中文名称（如果适用）
            let chineseRegion = region;
            if (region && region.trim()) {
                const regionUpper = region.trim().toUpperCase();
                if (regionCodeToChinese[regionUpper]) {
                    chineseRegion = regionCodeToChinese[regionUpper];
                }
            }

            // 转换城市名为中文名称（如果适用）
            let chineseCity = city;
            if (city && city.trim()) {
                const cityUpper = city.trim().toUpperCase();
                if (regionCodeToChinese[cityUpper]) {
                    chineseCity = regionCodeToChinese[cityUpper];
                }
            }

            // 转换国家名为中文名称（如果适用）
            let chineseCountry = country;
            if (country && country.trim()) {
                const countryName = country.trim();
                if (countryNameToChinese[countryName]) {
                    chineseCountry = countryNameToChinese[countryName];
                }
            }

            // 构建别名部分 - 按照需求1的顺序：城市/地区码，下载速度，端口，国家
            const parts = [];

            // 1. 城市或地区码（优先地区码，然后城市）
            if (chineseRegion && chineseRegion.trim()) {
                parts.push(chineseRegion.trim());
            } else if (chineseCity && chineseCity.trim()) {
                parts.push(chineseCity.trim());
            }

            // 2. 下载速度（如果有）
            if (speed && speed.trim()) {
                // 提取数字部分
                const speedMatch = speed.match(/(\d+(\.\d+)?)/);
                if (speedMatch) {
                    parts.push(`${speedMatch[1]}MB/s`);
                }
            }

            // 3. 端口
            parts.push(port.toString());

            // 4. 国家（如果有）
            if (chineseCountry && chineseCountry.trim()) {
                parts.push(chineseCountry.trim());
            }

            // 确定地区key用于分组
            let regionKey = '';
            if (chineseRegion && chineseRegion.trim()) {
                regionKey = chineseRegion.trim();
            } else if (chineseCity && chineseCity.trim()) {
                regionKey = chineseCity.trim();
            } else if (chineseCountry && chineseCountry.trim()) {
                regionKey = chineseCountry.trim();
            } else {
                // 如果CSV中没有任何地区信息，使用IP检测的地区
                const detectedLocation = getLocation(ip);
                regionKey = detectedLocation !== '未知' ? detectedLocation : config.prefix;
            }

            // 如果没有任何信息，使用IP检测的地区
            if (parts.length === 0) {
                const detectedLocation = getLocation(ip);
                parts.push(detectedLocation !== '未知' ? detectedLocation : config.prefix);
                parts.push(port.toString());
                parts.push(ip);
                regionKey = detectedLocation !== '未知' ? detectedLocation : config.prefix;
            }

            return {
                remark: parts.join('-'),
                regionKey: regionKey
            };
        }

        // 解析粘贴文本 - 修复：使用新的别名生成逻辑
        // 解析粘贴文本 - 修复别名生成逻辑，按照需求2生成别名
        function parsePasteText(text, config) {
            const ipPortPairs = smartSplitIPPort(text);
            const nodes = [];
            const regionGroups = {};

            ipPortPairs.forEach(pair => {
                const { ip, port } = pair;

                if (!ip) return;

                // 强制使用443端口（如果勾选了此选项）
                let finalPort = port;
                if (config.force443) {
                    finalPort = 443;
                }
                // 如果没有找到端口，使用默认端口
                else if (!finalPort) {
                    finalPort = config.defaultPort;
                }

                // 使用IP检测获取地区信息
                const location = getLocation(ip);
                const regionName = location !== '未知' ? location : config.prefix;

                // 初始化地区组
                if (!regionGroups[regionName]) {
                    regionGroups[regionName] = {
                        nodes: [],
                        counter: 1
                    };
                }

                // 为当前节点生成序号
                const sequence = regionGroups[regionName].counter.toString().padStart(2, '0');

                // 生成别名：地区名序号-端口-IP（如：香港01-443-127.0.0.1）
                const remark = `${regionName}${sequence}-${finalPort}-${ip}`;

                // 保存节点信息
                regionGroups[regionName].nodes.push({
                    ip: ip,
                    port: finalPort,
                    remark: remark,
                    config: config
                });

                // 增加计数器
                regionGroups[regionName].counter++;
            });

            // 生成所有节点
            Object.keys(regionGroups).forEach(regionName => {
                regionGroups[regionName].nodes.forEach(node => {
                    nodes.push(generateLink(node.ip, node.port, node.config, node.remark));
                });
            });

            return nodes;
        }

        // 新增：智能分割IP和端口 - 修复：支持多个空格分隔
        function smartSplitIPPort(text) {
            const result = [];
            const seen = new Set(); // 用于去重

            // 替换常见分隔符为统一的分隔符，处理多个空格
            let normalizedText = text.replace(/[,;\s]+/g, ' ');
            normalizedText = normalizedText.replace(/\s+/g, ' '); // 将多个空格替换为单个空格

            // 使用正则表达式匹配IP:端口或IP 端口
            // 匹配格式: IP:端口 或 IP 端口 或 只有IP
            // 修复：支持IP和端口之间多个空格的情况
            const ipPortPattern = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?:\s*[:,\s]\s*(\d{1,5}))?/g;

            let match;
            while ((match = ipPortPattern.exec(text)) !== null) {
                const ip = match[1];
                const port = match[2] ? parseInt(match[2]) : null;

                // 验证IP有效性
                if (!isValidIP(ip)) continue;

                // 验证端口有效性
                if (port !== null && (port < 1 || port > 65535)) continue;

                // 去重
                const key = `${ip}:${port || 'default'}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    result.push({ ip, port });
                }
            }

            // 如果没有匹配到IP:端口格式，尝试其他格式
            if (result.length === 0) {
                // 分割文本成单词
                const words = normalizedText.split(/\s+/).filter(w => w.trim());

                for (let i = 0; i < words.length; i++) {
                    const word = words[i].trim();

                    // 检查是否是IP地址
                    if (isValidIP(word)) {
                        const ip = word;
                        let port = null;

                        // 检查下一个单词是否是端口
                        if (i + 1 < words.length) {
                            const nextWord = words[i + 1];
                            const possiblePort = parseInt(nextWord);
                            if (!isNaN(possiblePort) && possiblePort >= 1 && possiblePort <= 65535) {
                                port = possiblePort;
                                i++; // 跳过端口单词
                            }
                        }

                        // 去重
                        const key = `${ip}:${port || 'default'}`;
                        if (!seen.has(key)) {
                            seen.add(key);
                            result.push({ ip, port });
                        }
                    }
                    // 检查是否是IP:端口格式（已处理过，但这里作为后备）
                    else if (word.includes(':')) {
                        const parts = word.split(':');
                        if (parts.length === 2) {
                            const ip = parts[0].trim();
                            const portStr = parts[1].trim();

                            if (isValidIP(ip)) {
                                const port = parseInt(portStr);
                                if (!isNaN(port) && port >= 1 && port <= 65535) {
                                    const key = `${ip}:${port}`;
                                    if (!seen.has(key)) {
                                        seen.add(key);
                                        result.push({ ip, port });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return result;
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const next = line[i + 1];

                if (char === '"' && !inQuotes) inQuotes = true;
                else if (char === '"' && inQuotes && next === '"') { current += '"'; i++; }
                else if (char === '"' && inQuotes) inQuotes = false;
                else if (char === ',' && !inQuotes) { result.push(current.trim()); current = ''; }
                else current += char;
            }
            result.push(current.trim());
            return result;
        }

        function generateLink(ip, port, config, remark) {
            const params = [
                'encryption=none',
                'security=tls',
                `sni=${encodeURIComponent(config.sni)}`,
                `fp=${config.fp}`,
                'type=ws',
                `host=${encodeURIComponent(config.host)}`,
                'path=%2F',
                'alpn=h2%2Chttp%2F1.1',
                'flow='
            ];
            return `vless://${config.uuid}@${ip}:${port}?${params.join('&')}#${encodeURIComponent(remark)}`;
        }

        function displayVlessLinks() {
            const el = document.getElementById('vless-links');
            el.textContent = data.vlessLinks.length ? data.vlessLinks.join('\n\n') : 'Vless链接将在这里显示...';
            el.classList.toggle('empty', data.vlessLinks.length === 0);
            document.getElementById('resultCount').textContent = `${data.vlessLinks.length}节点`;
            document.getElementById('localNodeCount').textContent = `${data.vlessLinks.length}节点`;
        }

        function convertManualToBase64() {
            const input = document.getElementById('manualVlessInput').value.trim();
            if (!input) {
                showNotification('转换失败', '请先粘贴Vless节点链接，每行一个vless://开头的链接', 'error');
                return;
            }

            const lines = input.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
            if (lines.length === 0) {
                showNotification('转换失败', '未检测到有效vless链接，请确保每行以vless://开头', 'error');
                return;
            }

            const plain = lines.join('\n');
            data.manualBase64Content = btoa(plain);

            const sec = document.getElementById('manualBase64Section');
            sec.style.display = 'block';
            document.getElementById('manualBase64Output').textContent = data.manualBase64Content;
            document.getElementById('manualBase64Output').classList.remove('empty');

            showNotification('转换成功', `成功转换 ${lines.length} 个节点为Base64订阅，可用于导入客户端`, 'success');
            addLog('转换节点', `成功转换 ${lines.length} 个节点为Base64订阅`, 'success');
        }

        // 新增：手动Vless转YAML
        function convertManualToYaml() {
            const input = document.getElementById('manualVlessInput3').value.trim();
            if (!input) {
                showNotification('转换失败', '请先粘贴Vless节点链接，每行一个vless://开头的链接', 'error');
                return;
            }

            const lines = input.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
            if (lines.length === 0) {
                showNotification('转换失败', '未检测到有效vless链接，请确保每行以vless://开头', 'error');
                return;
            }

            // 生成Clash YAML配置
            data.manualYamlContent = generateClashYAML(lines);

            const sec = document.getElementById('manualYamlSection');
            sec.style.display = 'block';
            document.getElementById('manualYamlOutput').textContent = data.manualYamlContent;
            document.getElementById('manualYamlOutput').classList.remove('empty');

            showNotification('转换成功', `成功转换 ${lines.length} 个节点为Clash YAML配置`, 'success');
            addLog('转换节点', `成功转换 ${lines.length} 个节点为Clash YAML配置`, 'success');
        }

        // 新增：测试Vless URL解析
        function testVlessParse() {
            const input = document.getElementById('manualVlessInput3').value.trim();
            if (!input) {
                showNotification('测试失败', '请先粘贴Vless节点链接进行测试', 'error');
                return;
            }

            const lines = input.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
            if (lines.length === 0) {
                showNotification('测试失败', '未检测到有效vless链接', 'error');
                return;
            }

            let successCount = 0;
            let failCount = 0;
            const results = [];

            lines.forEach((line, index) => {
                const parsed = parseVlessUrl(line.trim());
                if (parsed) {
                    successCount++;
                    results.push(`✅ 节点${index + 1}: ${parsed.name} (${parsed.server}:${parsed.port})`);
                } else {
                    failCount++;
                    results.push(`❌ 节点${index + 1}: 解析失败 - ${line.substring(0, 50)}...`);
                }
            });

            const resultText = results.join('\n');
            const sec = document.getElementById('manualYamlSection');
            sec.style.display = 'block';
            document.getElementById('manualYamlOutput').textContent = `解析测试结果:\n成功: ${successCount} 个\n失败: ${failCount} 个\n\n${resultText}`;
            document.getElementById('manualYamlOutput').classList.remove('empty');

            if (failCount === 0) {
                showNotification('测试成功', `所有 ${successCount} 个节点解析成功`, 'success');
            } else {
                showNotification('测试完成', `成功: ${successCount} 个, 失败: ${failCount} 个`, 'warning');
            }
        }

        // 新增：下载手动转换的YAML
        function downloadManualYaml() {
            if (!data.manualYamlContent) {
                showNotification('下载失败', '请先转换Vless节点为YAML格式', 'error');
                return;
            }

            const filename = `manual-clash-config-${new Date().toISOString().split('T')[0]}.yaml`;
            const blob = new Blob([data.manualYamlContent], { type: 'application/x-yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('下载成功', `${filename} 已下载`, 'success');
            addLog('下载配置', `下载了手动转换的Clash YAML配置文件`, 'success');
        }

        // 新增：下载合并生成的YAML
        function downloadMergedYaml() {
            if (!data.mergedYamlContent) {
                showNotification('下载失败', '请先合并节点生成YAML配置', 'error');
                return;
            }

            const filename = `merged-clash-config-${new Date().toISOString().split('T')[0]}.yaml`;
            const blob = new Blob([data.mergedYamlContent], { type: 'application/x-yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('下载成功', `${filename} 已下载`, 'success');
            addLog('下载配置', `下载了合并生成的Clash YAML配置文件`, 'success');
        }

        // 新增：下载本地生成的YAML
        function downloadLocalYaml() {
            if (!data.localYamlContent) {
                showNotification('下载失败', '请先生成本地节点生成YAML配置', 'error');
                return;
            }

            const filename = `local-clash-config-${new Date().toISOString().split('T')[0]}.yaml`;
            const blob = new Blob([data.localYamlContent], { type: 'application/x-yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('下载成功', `${filename} 已下载`, 'success');
            addLog('下载配置', `下载了本地生成的Clash YAML配置文件`, 'success');
        }

        // 新增：上传手动转换的YAML配置到GitHub
        async function uploadManualYaml() {
            if (!data.manualYamlContent) {
                showNotification('上传失败', '请先转换Vless节点为YAML格式', 'error');
                return;
            }

            showLoading(true, 'uploadYamlBtn');
            try {
                const token = document.getElementById('githubToken').value.trim();
                if (!token) {
                    showNotification('上传失败', '请先输入GitHub Token，否则无法上传文件', 'error');
                    showLoading(false, 'uploadYamlBtn');
                    return;
                }

                const repo = document.getElementById('githubRepo').value.trim();
                if (!repo) {
                    showNotification('上传失败', '请先输入GitHub仓库名称，格式为：用户名/仓库名', 'error');
                    showLoading(false, 'uploadYamlBtn');
                    return;
                }

                // 获取YAML文件名，默认为 clash-config.yaml
                const yamlFileName = document.getElementById('yamlFileName').value.trim() || 'clash-config.yaml';

                // 使用通用上传函数
                const result = await uploadToGitHub(
                    yamlFileName,
                    utf8ToBase64(data.manualYamlContent),
                    false, // YAML文件不需要Base64编码
                    `上传手动转换的Clash YAML配置 - ${new Date().toLocaleString()}`
                );

                // 标记缓存需要更新
                data.cache.needsUpdate = true;

                const message = result.isNew
                    ? `✅ 新建YAML配置文件 ${yamlFileName} 成功！`
                    : `✅ 更新YAML配置文件 ${yamlFileName} 成功！`;

                showNotification('上传成功', message, 'success');
                addLog('上传YAML配置', `${message} (SHA: ${result.sha.substring(0, 8)}...)`, 'success');

                // 显示GitHub.io链接
                showGithubLink('yamlConfigLink', 'yamlConfigUrl', result.githubIoUrl);
            } catch (e) {
                showNotification('上传失败', '上传过程中发生错误: ' + e.message, 'error');
                addLog('上传YAML配置', '上传失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'uploadYamlBtn');
            }
        }

        // 新增：手动Vless转IP:端口
        function convertManualToIpPort() {
            const input = document.getElementById('manualVlessInput2').value.trim();
            if (!input) {
                showNotification('转换失败', '请先粘贴Vless节点链接，每行一个vless://开头的链接', 'error');
                return;
            }

            const lines = input.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
            if (lines.length === 0) {
                showNotification('转换失败', '未检测到有效vless链接，请确保每行以vless://开头', 'error');
                return;
            }

            const ipPortList = [];
            lines.forEach(line => {
                // 提取IP和端口
                const match = line.match(/vless:\/\/[^@]+@([^:]+):(\d+)/);
                if (match) {
                    const ip = match[1];
                    const port = match[2];
                    ipPortList.push(`${ip}:${port}`);
                }
            });

            if (ipPortList.length === 0) {
                showNotification('转换失败', '无法从Vless链接中提取IP和端口', 'error');
                return;
            }

            data.manualIpPortContent = ipPortList.join('\n');

            const sec = document.getElementById('manualIpPortSection');
            sec.style.display = 'block';
            document.getElementById('manualIpPortOutput').textContent = data.manualIpPortContent;
            document.getElementById('manualIpPortOutput').classList.remove('empty');

            showNotification('转换成功', `成功提取 ${ipPortList.length} 个IP:端口组合`, 'success');
            addLog('提取IP端口', `成功提取 ${ipPortList.length} 个IP:端口组合`, 'success');
        }

        // 新增：下载IP:端口TXT文件
        function downloadIpPortTxt() {
            if (!data.manualIpPortContent) {
                showNotification('下载失败', '请先提取IP:端口', 'error');
                return;
            }

            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            downloadBlob(data.manualIpPortContent, `ip_port_${timestamp}.txt`);
            showNotification('下载成功', 'IP:端口文件已下载到本地', 'success');
            addLog('下载文件', 'IP:端口TXT文件已下载', 'success');
        }

        // 新增：统一的确认对话框 - 更简洁大气，支持键盘快捷键
        function showConfirmDialog(title, message, onConfirm, onCancel = null, type = 'info') {
            // 移除已存在的对话框
            const existingDialog = document.querySelector('.custom-dialog-overlay');
            if (existingDialog) {
                existingDialog.remove();
                if (dialogKeyHandler) {
                    document.removeEventListener('keydown', dialogKeyHandler);
                    dialogKeyHandler = null;
                }
            }

            // 创建遮罩层
            const overlay = document.createElement('div');
            overlay.className = 'custom-dialog-overlay';

            // 根据类型设置图标
            let iconText = '!';
            let dialogClass = '';

            if (type === 'warning') iconText = '⚠';
            else if (type === 'error') iconText = '✕';
            else if (type === 'success') iconText = '✓';

            if (type !== 'info') dialogClass = ` ${type}`;

            // 创建对话框
            const dialog = document.createElement('div');
            dialog.className = `custom-dialog${dialogClass}`;
            dialog.tabIndex = -1; // 使对话框可聚焦

            dialog.innerHTML = `
            <div class="custom-dialog-header">
                <div class="custom-dialog-icon">${iconText}</div>
                <h3 class="custom-dialog-title">${title}</h3>
            </div>
            <div class="custom-dialog-content">${message}</div>
            <div class="custom-dialog-actions">
                <button class="custom-dialog-btn custom-dialog-btn-cancel" id="dialogCancelBtn">
                    取消 (ESC)
                </button>
                <button class="custom-dialog-btn custom-dialog-btn-confirm" id="dialogConfirmBtn">
                    确认 (Enter)
                </button>
            </div>
        `;

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            // 关闭对话框函数
            const closeDialog = (action) => {
                // 移除事件监听
                if (dialogKeyHandler) {
                    document.removeEventListener('keydown', dialogKeyHandler);
                    dialogKeyHandler = null;
                }
                overlay.remove();

                // 执行相应的回调
                if (action === 'confirm' && onConfirm) {
                    onConfirm();
                } else if (action === 'cancel' && onCancel) {
                    onCancel();
                }
            };

            // 键盘事件处理函数
            dialogKeyHandler = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeDialog('cancel');
                } else if (e.key === 'Enter' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeDialog('confirm');
                }
            };

            // 添加键盘事件监听
            document.addEventListener('keydown', dialogKeyHandler);

            // 绑定按钮点击事件
            document.getElementById('dialogConfirmBtn').addEventListener('click', () => {
                closeDialog('confirm');
            });

            document.getElementById('dialogCancelBtn').addEventListener('click', () => {
                closeDialog('cancel');
            });

            // 点击遮罩层关闭（相当于取消）
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeDialog('cancel');
                }
            });

            // 对话框获取焦点，方便键盘操作
            setTimeout(() => {
                dialog.focus();
                document.getElementById('dialogCancelBtn').focus(); // 默认焦点在取消按钮
            }, 100);
        }

        // 新增：验证并合并 - 智能缓存检查
        function validateAndMerge() {
            const localCount = data.vlessLinks.length;
            const remoteCount = data.remoteNodes.length;
            const cachedRemoteCount = data.cache.remoteNodes.length;

            // 检查是否有可用的节点数据
            if (localCount === 0 && remoteCount === 0 && cachedRemoteCount === 0) {
                showConfirmDialog(
                    '无法合并',
                    '本地和远程都没有节点数据，无法进行合并操作。<br><br>请先生成本地节点或下载远程订阅。',
                    () => {
                        showNotification('提示', '请先生成节点或下载远程订阅', 'info');
                    },
                    null,
                    'warning'
                );
                return;
            }

            // 检查是否需要使用缓存数据
            if (localCount > 0 && remoteCount === 0 && cachedRemoteCount > 0) {
                showConfirmDialog(
                    '使用缓存数据',
                    `本地有 <strong>${localCount}</strong> 个节点，远程节点数据为空，但缓存中有 <strong>${cachedRemoteCount}</strong> 个远程节点。<br><br>是否使用缓存中的远程节点进行合并？<br><br>提示：如果缓存数据可能已过时，建议重新下载远程订阅。`,
                    () => {
                        // 使用缓存数据
                        data.remoteNodes = [...data.cache.remoteNodes];
                        data.stats.remote = data.remoteNodes.length;
                        updateStats();
                        mergeAndShow();
                    },
                    () => {
                        // 用户选择不合并
                        showNotification('提示', '已取消合并操作', 'info');
                    },
                    'info'
                );
                return;
            }

            // 检查本地节点是否为空
            if (localCount === 0 && (remoteCount > 0 || cachedRemoteCount > 0)) {
                const actualRemoteCount = remoteCount > 0 ? remoteCount : cachedRemoteCount;
                showConfirmDialog(
                    '确认合并',
                    `本地没有生成节点，但有 <strong>${actualRemoteCount}</strong> 个远程节点。<br><br>是否继续合并（仅使用远程节点）？<br><br>提示：您可以先生成本地节点再合并。`,
                    () => {
                        // 如果当前远程节点为空但缓存有数据，使用缓存
                        if (remoteCount === 0 && cachedRemoteCount > 0) {
                            data.remoteNodes = [...data.cache.remoteNodes];
                            data.stats.remote = data.remoteNodes.length;
                            updateStats();
                        }
                        mergeAndShow();
                    },
                    () => {
                        // 用户选择不合并
                        showNotification('提示', '已取消合并操作', 'info');
                    },
                    'info'
                );
                return;
            }

            // 检查远程节点是否为空
            if (remoteCount === 0 && localCount > 0) {
                showConfirmDialog(
                    '确认合并',
                    `远程没有节点，本地有 <strong>${localCount}</strong> 个节点。<br><br>是否继续合并（仅使用本地节点）？<br><br>提示：您可以先下载远程订阅再合并。`,
                    () => {
                        mergeAndShow();
                    },
                    () => {
                        // 用户选择不合并
                        showNotification('提示', '已取消合并操作', 'info');
                    },
                    'info'
                );
                return;
            }

            // 正常合并
            const totalNodes = localCount + remoteCount;
            showConfirmDialog(
                '确认合并',
                `即将合并本地 <strong>${localCount}</strong> 个节点和远程 <strong>${remoteCount}</strong> 个节点，总计 <strong>${totalNodes}</strong> 个节点。<br><br>合并后将自动去重并重新设置别名。<br><br>是否继续？`,
                () => {
                    mergeAndShow();
                },
                () => {
                    // 用户选择不合并
                    showNotification('提示', '已取消合并操作', 'info');
                },
                'info'
            );
        }

        // 新增：验证并上传
        function validateAndUpload(uploadFunction) {
            let nodeCount = 0;
            let targetPath = '';
            let uploadFunc = null;
            let uploadType = '';

            // 根据不同的上传函数设置参数
            switch (uploadFunction) {
                case 'uploadLocalBase64ToPath':
                    nodeCount = data.vlessLinks.length;
                    if (nodeCount === 0) {
                        showNotification('上传失败', '请先生成本地节点，当前没有可上传的节点数据', 'warning');
                        return;
                    }
                    const uploadPathSelect = document.getElementById('uploadPathSelect');
                    let uploadPath = uploadPathSelect.value;
                    if (uploadPath === 'custom') {
                        const customPath = document.getElementById('customUploadPath').value.trim();
                        if (!customPath) {
                            showNotification('上传失败', '请输入自定义上传路径，或选择预定义路径', 'error');
                            return;
                        }
                        targetPath = customPath;
                    } else {
                        targetPath = uploadPath;
                    }
                    uploadFunc = () => uploadLocalBase64ToPath();
                    uploadType = '本地订阅';
                    break;

                case 'uploadPlainNodes':
                    nodeCount = data.uniqueNodes.length;
                    if (nodeCount === 0) {
                        showNotification('上传失败', '请先合并节点，当前没有可上传的合并节点数据', 'warning');
                        return;
                    }
                    targetPath = document.getElementById('plainNodeFile').value.trim();
                    uploadFunc = () => uploadPlainNodes();
                    uploadType = '合并明文订阅';
                    break;

                case 'uploadMergedBase64':
                    nodeCount = data.uniqueNodes.length;
                    if (nodeCount === 0) {
                        showNotification('上传失败', '请先合并节点，当前没有可上传的合并节点数据', 'warning');
                        return;
                    }
                    targetPath = document.getElementById('mainNodeFile').value.trim();
                    uploadFunc = () => uploadMergedBase64();
                    uploadType = '合并主要订阅';
                    break;

                case 'uploadMergedOptimal':
                    nodeCount = data.uniqueNodes.length;
                    if (nodeCount === 0) {
                        showNotification('上传失败', '请先合并节点，当前没有可上传的合并节点数据', 'warning');
                        return;
                    }
                    targetPath = document.getElementById('optimalNodeFile').value.trim();
                    uploadFunc = () => uploadMergedOptimal();
                    uploadType = '合并优选订阅';
                    break;

                case 'uploadMergedToPath':
                    nodeCount = data.uniqueNodes.length;
                    if (nodeCount === 0) {
                        showNotification('上传失败', '请先合并节点，当前没有可上传的合并节点数据', 'warning');
                        return;
                    }
                    const pathSelect = document.getElementById('uploadPathSelect');
                    let selectedPath = pathSelect.value;
                    if (selectedPath === 'custom') {
                        const customPath = document.getElementById('customUploadPath').value.trim();
                        if (!customPath) {
                            showNotification('上传失败', '请输入自定义上传路径，或选择预定义路径', 'error');
                            return;
                        }
                        targetPath = customPath;
                    } else {
                        targetPath = selectedPath;
                    }
                    uploadFunc = () => uploadMergedToPath();
                    uploadType = '合并订阅到指定路径';
                    break;
            }

            if (nodeCount === 0) {
                showNotification('上传失败', '没有可上传的节点数据', 'warning');
                return;
            }

            showConfirmDialog(
                '确认上传',
                `将 <strong>${nodeCount} 个节点</strong> 上传到 <strong>${targetPath}</strong><br><br>上传类型：${uploadType}<br><br>是否继续？<br><br>提示：上传后将更新远程文件，请确保有正确的GitHub权限。`,
                uploadFunc,
                () => {
                    showNotification('提示', '已取消上传操作', 'info');
                },
                'info'
            );
        }

        // 修复：下载远程订阅功能 - 使用更简单可靠的逻辑
        async function downloadRemote() {
            showLoading(true, 'downloadSubBtn');
            try {
                const token = document.getElementById('githubToken').value.trim();
                if (!token) {
                    showNotification('下载失败', '请先输入GitHub Token，否则无法访问远程仓库', 'error');
                    showLoading(false, 'downloadSubBtn');
                    return;
                }

                const repo = document.getElementById('githubRepo').value.trim();
                if (!repo) {
                    showNotification('下载失败', '请先输入GitHub仓库名称，格式为：用户名/仓库名', 'error');
                    showLoading(false, 'downloadSubBtn');
                    return;
                }

                const branch = document.getElementById('githubBranch').value.trim() || 'main';

                // 获取选择的下载路径
                const urlSelect = document.getElementById('downloadUrlSelect');
                const selectedOption = urlSelect.value;
                let targetFile = '';

                if (selectedOption === 'custom') {
                    targetFile = document.getElementById('customDownloadUrl').value.trim();
                    if (!targetFile) {
                        showNotification('下载失败', '请输入自定义路径，或选择预定义路径', 'error');
                        showLoading(false, 'downloadSubBtn');
                        return;
                    }
                } else {
                    targetFile = selectedOption;
                }

                // 根据选择的路径设置要下载的文件
                const mainNodeFile = document.getElementById('mainNodeFile').value.trim();
                const plainNodeFile = document.getElementById('plainNodeFile').value.trim();
                const optimalNodeFile = document.getElementById('optimalNodeFile').value.trim();

                let downloadFiles = [];

                if (targetFile === 'MainNode') {
                    downloadFiles = [{ file: mainNodeFile, type: 'base64' }];
                } else if (targetFile === 'PlainNode') {
                    downloadFiles = [{ file: plainNodeFile, type: 'plain' }];
                } else if (targetFile === 'OptimalNode') {
                    downloadFiles = [{ file: optimalNodeFile, type: 'base64' }];
                } else {
                    // 自定义路径，尝试下载
                    downloadFiles = [{ file: targetFile, type: 'unknown' }];
                }

                // 清除当前远程节点数据，准备重新下载
                data.remoteNodes = [];

                let totalDownloaded = 0;
                let successCount = 0;

                for (const fileInfo of downloadFiles) {
                    try {
                        // 添加时间戳防止缓存
                        const timestamp = Date.now();
                        const fileUrl = `https://api.github.com/repos/${repo}/contents/${fileInfo.file}?ref=${branch}&t=${timestamp}`;

                        console.log(`正在下载文件: ${fileInfo.file}`, fileUrl);

                        const fileRes = await fetch(fileUrl, {
                            headers: {
                                Authorization: `token ${token}`,
                                Accept: 'application/vnd.github.v3+json'
                            }
                        });

                        if (fileRes.ok) {
                            const fileJson = await fileRes.json();
                            const fileContent = atob(fileJson.content.replace(/\n/g, ''));

                            console.log(`✅ 文件 ${fileInfo.file} 下载成功，原始内容长度: ${fileContent.length}`);

                            let nodes = [];

                            // 简化解析逻辑：首先尝试Base64解码
                            try {
                                // 先尝试解码一次Base64
                                const decodedContent = atob(fileContent);

                                // 检查解码后的内容是否包含vless://
                                if (decodedContent.includes('vless://')) {
                                    // 成功找到vless链接
                                    nodes = decodedContent.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
                                    console.log(`✅ Base64解码成功，找到 ${nodes.length} 个节点`);
                                } else {
                                    // 可能还有一层Base64编码（双重Base64）
                                    try {
                                        const doubleDecoded = atob(decodedContent);
                                        if (doubleDecoded.includes('vless://')) {
                                            nodes = doubleDecoded.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
                                            console.log(`✅ 双重Base64解码成功，找到 ${nodes.length} 个节点`);
                                        } else {
                                            // 如果都不是，尝试直接解析原始内容
                                            nodes = fileContent.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
                                            console.log(`✅ 直接解析找到 ${nodes.length} 个节点`);
                                        }
                                    } catch (e2) {
                                        // 双重Base64解码失败，尝试直接解析
                                        nodes = fileContent.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
                                        console.log(`✅ 双重Base64解码失败，直接解析找到 ${nodes.length} 个节点`);
                                    }
                                }
                            } catch (e) {
                                // Base64解码失败，直接解析原始内容
                                console.log(`⚠️ Base64解码失败，尝试直接解析: ${e.message}`);
                                nodes = fileContent.split(/\r?\n/).filter(l => l.trim().startsWith('vless://'));
                                console.log(`✅ 直接解析找到 ${nodes.length} 个节点`);
                            }

                            // 如果还没有节点，尝试最直接的解析方式
                            if (nodes.length === 0) {
                                // 直接按行分割，尝试查找vless链接
                                const lines = fileContent.split(/\r?\n/);
                                for (const line of lines) {
                                    if (line.includes('vless://')) {
                                        // 提取vless链接
                                        const vlessMatch = line.match(/vless:\/\/[^\s]+/);
                                        if (vlessMatch) {
                                            nodes.push(vlessMatch[0]);
                                        }
                                    }
                                }
                                console.log(`✅ 直接搜索vless链接找到 ${nodes.length} 个节点`);
                            }

                            data.remoteNodes = [...data.remoteNodes, ...nodes];
                            totalDownloaded += nodes.length;
                            successCount++;

                            // 保存sha值
                            if (fileInfo.file === mainNodeFile) {
                                data.nodeSha = fileJson.sha;
                            } else if (fileInfo.file === plainNodeFile) {
                                data.plainSha = fileJson.sha;
                            } else if (fileInfo.file === optimalNodeFile) {
                                data.optimalSha = fileJson.sha;
                            }
                        } else {
                            console.log(`❌ ${fileInfo.file} 文件下载失败: ${fileRes.status}`);
                            if (fileRes.status === 404) {
                                showNotification('文件不存在', `文件 ${fileInfo.file} 不存在于仓库中`, 'info');
                            } else {
                                const err = await fileRes.json();
                                console.log('错误详情:', err);
                            }
                        }
                    } catch (e) {
                        console.log(`❌ ${fileInfo.file} 文件下载失败:`, e);
                    }
                }

                // 去重
                const seen = new Set();
                const uniqueNodes = [];
                data.remoteNodes.forEach(node => {
                    // 提取IP和端口作为唯一标识
                    const match = node.match(/@([^:]+):(\d+)/);
                    const key = match ? `${match[1]}:${match[2]}` : node;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueNodes.push(node);
                    }
                });

                data.remoteNodes = uniqueNodes;
                data.stats.remote = data.remoteNodes.length;

                // 更新缓存
                data.cache.remoteNodes = [...data.remoteNodes];
                data.cache.lastDownloadTime = Date.now();
                data.cache.downloadPath = targetFile;
                data.cache.needsUpdate = false;

                updateStats();

                if (data.remoteNodes.length === 0) {
                    showNotification('下载完成', `从 ${targetFile} 获取到 0 个节点，文件可能为空、不存在或格式不支持`, 'info');
                    addLog('下载远程', `从 ${targetFile} 获取 0 个节点`, 'info');
                } else {
                    showNotification('下载成功', `成功从 ${targetFile} 下载 ${data.remoteNodes.length} 个节点，已自动去重`, 'success');
                    addLog('下载远程', `从 ${targetFile} 获取 ${data.remoteNodes.length} 个节点`, 'success');

                    // 如果本地已有节点，提示合并
                    if (data.vlessLinks.length > 0) {
                        setTimeout(() => {
                            showNotification('提示', `本地有 ${data.vlessLinks.length} 个节点，远程有 ${data.remoteNodes.length} 个节点，点击"合并节点"按钮进行合并`, 'info');
                        }, 500);
                    }
                }
            } catch (e) {
                console.error('❌ 下载失败:', e);
                showNotification('下载失败', '下载过程中发生错误: ' + e.message, 'error');
                addLog('下载远程', '下载失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'downloadSubBtn');
            }
        }
        // 新增：检测别名是否是格式化的别名
        function isFormattedAlias(remark) {
            if (!remark) return false;

            // 格式1：地区名+序号+端口 (如：日本01-443, 香港02-8080)
            const pattern1 = /^[^\d]+\d{2,}-\d+$/;

            // 格式2：地区名-序号-端口 (如：日本-01-443)
            const pattern2 = /^[^-]+-\d{2,}-\d+$/;

            // 格式3：包含中文或英文名称，不是IP:端口格式
            const isIpPort = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/.test(remark);

            return (pattern1.test(remark) || pattern2.test(remark)) && !isIpPort;
        }

        // 新增：提取别名中的地区名
        function extractRegionFromAlias(remark) {
            if (!remark) return null;

            // 尝试匹配格式：地区名+序号 或 地区名-序号
            const match1 = remark.match(/^([^\d]+)\d{2,}/); // 日本01-443
            if (match1) return match1[1].trim();

            const match2 = remark.match(/^([^-]+)-\d{2,}/); // 日本-01-443
            if (match2) return match2[1].trim();

            return null;
        }

        function mergeAndShow() {
            const all = [...data.vlessLinks, ...data.remoteNodes];
            const seen = new Set();
            data.uniqueNodes = [];

            // 提取所有节点的IP、端口和别名信息
            const nodeInfos = all.map(node => {
                // 使用更宽松的正则匹配
                const ipPortMatch = node.match(/@([^:]+):(\d+)/);
                const remarkMatch = node.match(/#([^"]+)/);

                if (ipPortMatch) {
                    const ip = ipPortMatch[1];
                    const port = ipPortMatch[2];
                    const remark = remarkMatch ? decodeURIComponent(remarkMatch[1]) : `${ip}:${port}`;

                    return {
                        ip: ip,
                        port: port,
                        remark: remark,
                        full: node,
                        source: data.vlessLinks.includes(node) ? 'local' : 'remote'
                    };
                }
                return null;
            }).filter(info => info !== null);

            // 去重：基于IP和端口
            const uniqueNodeMap = new Map();

            nodeInfos.forEach(info => {
                const key = `${info.ip}:${info.port}`;

                if (!uniqueNodeMap.has(key)) {
                    // 第一个遇到这个IP:端口的节点，直接使用
                    uniqueNodeMap.set(key, info);
                } else {
                    // 如果已经存在，选择更好的别名（优先保留有具体名称的）
                    const existing = uniqueNodeMap.get(key);
                    const existingHasName = existing.remark && !existing.remark.includes(':');
                    const newHasName = info.remark && !info.remark.includes(':');

                    // 规则：优先保留有具体名称的别名，而不是IP:端口格式
                    if (newHasName && !existingHasName) {
                        uniqueNodeMap.set(key, info);
                    }
                    // 如果都有名称或都没有名称，优先保留本地节点的别名
                    else if (info.source === 'local' && existing.source === 'remote') {
                        uniqueNodeMap.set(key, info);
                    }
                }
            });

            // 转换为数组
            const uniqueInfos = Array.from(uniqueNodeMap.values());

            // 检查是否需要重新设置别名
            const shouldRename = document.getElementById('renameOnMerge').checked;

            if (shouldRename && uniqueInfos.length > 0) {
                // 智能重命名：只重命名那些别名是IP:端口格式的节点
                const config = getConfig();
                const nodesToRename = [];
                const nodesToKeep = [];

                // 分类节点：哪些需要重命名，哪些保留
                uniqueInfos.forEach(info => {
                    // 判断是否是IP:端口格式
                    const isIpPortFormat = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/.test(info.remark);

                    if (isIpPortFormat) {
                        // IP:端口格式，需要重命名
                        nodesToRename.push(info);
                    } else {
                        // 其他格式的别名（可能是用户自定义的或已格式化的），保留
                        nodesToKeep.push(info);
                    }
                });

                // 对需要重命名的节点按地区分组
                const regionGroups = {};
                nodesToRename.forEach(info => {
                    const regionName = getLocation(info.ip);
                    const finalRegion = regionName !== '未知' ? regionName : config.prefix;

                    if (!regionGroups[finalRegion]) {
                        regionGroups[finalRegion] = {
                            nodes: [],
                            counter: 1
                        };
                    }

                    regionGroups[finalRegion].nodes.push({
                        ip: info.ip,
                        port: info.port,
                        config: config,
                        sequence: regionGroups[finalRegion].counter++
                    });
                });

                // 生成重命名后的节点
                const renamedNodes = [];
                Object.keys(regionGroups).forEach(regionName => {
                    regionGroups[regionName].nodes.forEach(node => {
                        const sequence = node.sequence.toString().padStart(2, '0');
                        // 只有IP和端口的情况，使用格式：地区名序号-端口-IP
                        const remark = `${regionName}${sequence}-${node.port}-${node.ip}`;
                        renamedNodes.push(generateLink(node.ip, node.port, node.config, remark));
                    });
                });

                // 保留不需要重命名的节点
                const keptNodes = nodesToKeep.map(info => info.full);

                // 合并所有节点
                data.uniqueNodes = [...renamedNodes, ...keptNodes];

                // 显示重命名统计
                if (renamedNodes.length > 0) {
                    showNotification('智能合并完成',
                        `共 ${uniqueInfos.length} 个节点：${renamedNodes.length} 个IP:端口格式的节点已重命名，${keptNodes.length} 个节点保留原有别名`,
                        'success');
                }

            } else {
                // 不重命名，直接使用原有别名
                data.uniqueNodes = uniqueInfos.map(info => info.full);
            }

            // 更新统计数据
            data.stats.merged = all.length;
            data.stats.unique = data.uniqueNodes.length;

            // 如果合并后节点数量为0，使用本地和远程节点数量中较大的一个
            if (data.stats.unique === 0) {
                data.stats.unique = Math.max(data.vlessLinks.length, data.remoteNodes.length);
            }

            updateStats();

            const plainText = data.uniqueNodes.join('\n');
            data.autoBase64Content = btoa(plainText);

            // 生成对应的YAML内容
            data.mergedYamlContent = data.uniqueNodes.length ? generateClashYAML(data.uniqueNodes) : '';

            document.getElementById('autoBase64Output').textContent = data.autoBase64Content;
            document.getElementById('autoBase64Output').classList.toggle('empty', data.uniqueNodes.length === 0);
            document.getElementById('mergedResult').textContent = data.uniqueNodes.length ? data.uniqueNodes.join('\n\n') : '无节点';
            document.getElementById('mergedYamlOutput').textContent = data.mergedYamlContent;
            document.getElementById('mergedYamlOutput').classList.toggle('empty', data.uniqueNodes.length === 0);

            // 显示合并完成通知
            if (data.uniqueNodes.length > 0) {
                addLog('合并节点', `合并完成！共 ${data.uniqueNodes.length} 个节点`, 'success');
            } else {
                addLog('合并节点', '合并完成，但未生成任何节点', 'info');
            }
        }

        // 修复：上传本地生成Base64到指定路径 - 修正文件格式问题
        async function uploadLocalBase64ToPath() {
            showLoading(true, 'uploadLocalBase64ToPathBtn');
            try {
                if (data.vlessLinks.length === 0) {
                    showNotification('上传失败', '请先生成本地节点，当前没有可上传的节点数据', 'error');
                    showLoading(false, 'uploadLocalBase64ToPathBtn');
                    return;
                }

                // 获取选择的上传路径
                const pathSelect = document.getElementById('uploadPathSelect');
                const selectedOption = pathSelect.value;
                let targetFile = '';

                if (selectedOption === 'custom') {
                    targetFile = document.getElementById('customUploadPath').value.trim();
                    if (!targetFile) {
                        showNotification('上传失败', '请输入自定义上传路径，或选择预定义路径', 'error');
                        showLoading(false, 'uploadLocalBase64ToPathBtn');
                        return;
                    }
                } else {
                    targetFile = selectedOption;
                }

                // 根据目标路径决定上传格式
                let contentToUpload = '';

                if (targetFile === 'PlainNode') {
                    // PlainNode：上传明文节点
                    const plainText = data.vlessLinks.join('\n');
                    contentToUpload = btoa(plainText);
                } else if (targetFile === 'OptimalNode' || targetFile === 'MainNode') {
                    // OptimalNode 和 MainNode：上传双重Base64编码
                    const firstBase64 = btoa(data.vlessLinks.join('\n'));
                    contentToUpload = btoa(firstBase64);
                } else {
                    // 其他自定义路径：使用本地生成的Base64内容
                    contentToUpload = data.localBase64Content || btoa(data.vlessLinks.join('\n'));
                }

                // 使用通用上传函数
                const result = await uploadToGitHub(
                    targetFile,
                    contentToUpload,
                    targetFile !== 'PlainNode',
                    `上传本地订阅到 ${targetFile} - ${new Date().toLocaleString()} (${data.vlessLinks.length}节点)`
                );

                // 标记缓存需要更新
                data.cache.needsUpdate = true;

                const message = result.isNew
                    ? `✅ 新建本地订阅文件 ${targetFile} 成功！包含 ${data.vlessLinks.length} 个节点`
                    : `✅ 更新本地订阅文件 ${targetFile} 成功！包含 ${data.vlessLinks.length} 个节点`;

                showNotification('上传成功', message, 'success');
                addLog('上传本地订阅', `${message} (SHA: ${result.sha.substring(0, 8)}...)`, 'success');

                // 显示GitHub.io链接
                showGithubLink('localBase64Link', 'localBase64Url', result.githubIoUrl);

                // 同时上传对应的YAML配置文件
                try {
                    const yamlFileName = targetFile.replace(/\.[^/.]+$/, '') + '.yaml'; // 替换扩展名为.yaml
                    const yamlContent = generateClashYAML(data.vlessLinks);

                    const yamlResult = await uploadToGitHub(
                        yamlFileName,
                        utf8ToBase64(yamlContent),
                        false,
                        `上传本地YAML配置 ${yamlFileName} - ${new Date().toLocaleString()} (${data.vlessLinks.length}节点)`
                    );

                    const yamlMessage = yamlResult.isNew
                        ? `✅ 新建YAML配置文件 ${yamlFileName} 成功！`
                        : `✅ 更新YAML配置文件 ${yamlFileName} 成功！`;

                    showNotification('YAML上传成功', yamlMessage, 'success');
                    addLog('上传YAML配置', `${yamlMessage} (SHA: ${yamlResult.sha.substring(0, 8)}...)`, 'success');

                    // 显示YAML配置文件的GitHub.io链接
                    showGithubLink('localYamlLink', 'localYamlUrl', yamlResult.githubIoUrl);
                } catch (yamlError) {
                    console.warn('YAML文件上传失败，但节点文件已成功上传:', yamlError);
                    showNotification('YAML上传失败', '节点文件上传成功，但YAML配置文件上传失败: ' + yamlError.message, 'warning');
                }
            } catch (e) {
                showNotification('上传失败', '上传过程中发生错误: ' + e.message, 'error');
                addLog('上传本地订阅', '上传失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'uploadLocalBase64ToPathBtn');
            }
        }

        // 修复：上传合并Base64到MainNode
        async function uploadMergedBase64() {
            showLoading(true, 'uploadMergedBase64Btn');
            try {
                if (data.uniqueNodes.length === 0) {
                    showNotification('上传失败', '请先合并节点，当前没有可上传的合并节点数据', 'error');
                    showLoading(false, 'uploadMergedBase64Btn');
                    return;
                }

                const mainNodeFile = document.getElementById('mainNodeFile').value.trim();
                const plainText = data.uniqueNodes.join('\n');

                // 修复：双重Base64编码（符合订阅格式）
                const firstBase64 = btoa(plainText);
                const finalContent = btoa(firstBase64);

                // 使用通用上传函数
                const result = await uploadToGitHub(
                    mainNodeFile,
                    finalContent,
                    true,
                    `上传合并Base64订阅到 ${mainNodeFile} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                );

                // 标记缓存需要更新
                data.cache.needsUpdate = true;

                const message = result.isNew
                    ? `✅ 新建Base64订阅文件 ${mainNodeFile} 成功！包含 ${data.uniqueNodes.length} 个节点`
                    : `✅ 更新Base64订阅文件 ${mainNodeFile} 成功！包含 ${data.uniqueNodes.length} 个节点`;

                showNotification('上传成功', message, 'success');
                addLog('上传合并Base64', `${message} (SHA: ${result.sha.substring(0, 8)}...)`, 'success');

                // 显示GitHub.io链接
                showGithubLink('mergedBase64Link', 'mergedBase64Url', result.githubIoUrl);

                // 同时上传对应的YAML配置文件
                try {
                    const yamlFileName = mainNodeFile.replace(/\.[^/.]+$/, '') + '.yaml';
                    const yamlContent = data.mergedYamlContent;

                    const yamlResult = await uploadToGitHub(
                        yamlFileName,
                        utf8ToBase64(yamlContent),
                        false,
                        `上传合并YAML配置 ${yamlFileName} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                    );

                    const yamlMessage = yamlResult.isNew
                        ? `✅ 新建YAML配置文件 ${yamlFileName} 成功！`
                        : `✅ 更新YAML配置文件 ${yamlFileName} 成功！`;

                    showNotification('YAML上传成功', yamlMessage, 'success');
                    addLog('上传YAML配置', `${yamlMessage} (SHA: ${yamlResult.sha.substring(0, 8)}...)`, 'success');

                    // 显示YAML配置文件的GitHub.io链接
                    showGithubLink('mergedYamlLink', 'mergedYamlUrl', yamlResult.githubIoUrl);
                } catch (yamlError) {
                    console.warn('YAML文件上传失败，但节点文件已成功上传:', yamlError);
                    showNotification('YAML上传失败', '节点文件上传成功，但YAML配置文件上传失败: ' + yamlError.message, 'warning');
                }
            } catch (e) {
                showNotification('上传失败', '上传过程中发生错误: ' + e.message, 'error');
                addLog('上传合并Base64', '上传失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'uploadMergedBase64Btn');
            }
        }

        // 修复：上传合并订阅到OptimalNode
        async function uploadMergedOptimal() {
            showLoading(true, 'uploadMergedOptimalBtn');
            try {
                if (data.uniqueNodes.length === 0) {
                    showNotification('上传失败', '请先合并节点，当前没有可上传的合并节点数据', 'error');
                    showLoading(false, 'uploadMergedOptimalBtn');
                    return;
                }

                const optimalNodeFile = document.getElementById('optimalNodeFile').value.trim();
                const plainText = data.uniqueNodes.join('\n');

                // 双重Base64编码（符合订阅格式）
                const firstBase64 = btoa(plainText);
                const finalContent = btoa(firstBase64);

                // 使用通用上传函数
                const result = await uploadToGitHub(
                    optimalNodeFile,
                    finalContent,
                    true,
                    `上传合并优选订阅到 ${optimalNodeFile} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                );

                // 标记缓存需要更新
                data.cache.needsUpdate = true;

                const message = result.isNew
                    ? `✅ 新建优选订阅文件 ${optimalNodeFile} 成功！包含 ${data.uniqueNodes.length} 个节点`
                    : `✅ 更新优选订阅文件 ${optimalNodeFile} 成功！包含 ${data.uniqueNodes.length} 个节点`;

                showNotification('上传成功', message, 'success');
                addLog('上传合并优选订阅', `${message} (SHA: ${result.sha.substring(0, 8)}...)`, 'success');

                // 显示GitHub.io链接
                showGithubLink('mergedOptimalLink', 'mergedOptimalUrl', result.githubIoUrl);

                // 同时上传对应的YAML配置文件（使用与MainNode相同的文件名模式）
                try {
                    const yamlFileName = optimalNodeFile.replace(/\.[^/.]+$/, '') + '.yaml';
                    const yamlContent = data.mergedYamlContent;

                    const yamlResult = await uploadToGitHub(
                        yamlFileName,
                        utf8ToBase64(yamlContent),
                        false,
                        `上传合并YAML配置 ${yamlFileName} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                    );

                    const yamlMessage = yamlResult.isNew
                        ? `✅ 新建YAML配置文件 ${yamlFileName} 成功！`
                        : `✅ 更新YAML配置文件 ${yamlFileName} 成功！`;

                    showNotification('YAML上传成功', yamlMessage, 'success');
                    addLog('上传YAML配置', `${yamlMessage} (SHA: ${yamlResult.sha.substring(0, 8)}...)`, 'success');

                    // 显示YAML配置文件的GitHub.io链接（复用mergedYamlLink）
                    showGithubLink('mergedYamlLink', 'mergedYamlUrl', yamlResult.githubIoUrl);
                } catch (yamlError) {
                    console.warn('YAML文件上传失败，但节点文件已成功上传:', yamlError);
                    showNotification('YAML上传失败', '节点文件上传成功，但YAML配置文件上传失败: ' + yamlError.message, 'warning');
                }
            } catch (e) {
                showNotification('上传失败', '上传过程中发生错误: ' + e.message, 'error');
                addLog('上传合并优选订阅', '上传失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'uploadMergedOptimalBtn');
            }
        }

        // 新增：上传合并订阅至指定路径
        async function uploadMergedToPath() {
            showLoading(true, 'uploadMergedToPathBtn');
            try {
                if (data.uniqueNodes.length === 0) {
                    showNotification('上传失败', '请先合并节点，当前没有可上传的合并节点数据', 'error');
                    showLoading(false, 'uploadMergedToPathBtn');
                    return;
                }

                // 获取选择的上传路径
                const pathSelect = document.getElementById('uploadPathSelect');
                const selectedOption = pathSelect.value;
                let targetFile = '';

                if (selectedOption === 'custom') {
                    targetFile = document.getElementById('customUploadPath').value.trim();
                    if (!targetFile) {
                        showNotification('上传失败', '请输入自定义上传路径，或选择预定义路径', 'error');
                        showLoading(false, 'uploadMergedToPathBtn');
                        return;
                    }
                } else {
                    targetFile = selectedOption;
                }

                const plainText = data.uniqueNodes.join('\n');
                let contentToUpload = '';

                // 根据目标路径决定上传格式
                if (targetFile === 'PlainNode') {
                    // PlainNode：上传明文节点
                    contentToUpload = btoa(plainText);
                } else if (targetFile === 'OptimalNode' || targetFile === 'MainNode') {
                    // OptimalNode 和 MainNode：上传双重Base64编码
                    const firstBase64 = btoa(plainText);
                    contentToUpload = btoa(firstBase64);
                } else {
                    // 其他自定义路径：使用双重Base64编码
                    const firstBase64 = btoa(plainText);
                    contentToUpload = btoa(firstBase64);
                }

                // 使用通用上传函数
                const result = await uploadToGitHub(
                    targetFile,
                    contentToUpload,
                    targetFile !== 'PlainNode',
                    `上传合并订阅到指定路径 ${targetFile} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                );

                // 标记缓存需要更新
                data.cache.needsUpdate = true;

                const message = result.isNew
                    ? `✅ 新建合并订阅文件 ${targetFile} 成功！包含 ${data.uniqueNodes.length} 个节点`
                    : `✅ 更新合并订阅文件 ${targetFile} 成功！包含 ${data.uniqueNodes.length} 个节点`;

                showNotification('上传成功', message, 'success');
                addLog('上传合并至指定路径', `${message} (SHA: ${result.sha.substring(0, 8)}...)`, 'success');

                // 显示GitHub.io链接
                showGithubLink('mergedToPathLink', 'mergedToPathUrl', result.githubIoUrl);

                // 同时上传对应的YAML配置文件
                try {
                    const yamlFileName = targetFile.replace(/\.[^/.]+$/, '') + '.yaml';
                    const yamlContent = data.mergedYamlContent;

                    const yamlResult = await uploadToGitHub(
                        yamlFileName,
                        utf8ToBase64(yamlContent),
                        false,
                        `上传合并YAML配置 ${yamlFileName} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                    );

                    const yamlMessage = yamlResult.isNew
                        ? `✅ 新建YAML配置文件 ${yamlFileName} 成功！`
                        : `✅ 更新YAML配置文件 ${yamlFileName} 成功！`;

                    showNotification('YAML上传成功', yamlMessage, 'success');
                    addLog('上传YAML配置', `${yamlMessage} (SHA: ${yamlResult.sha.substring(0, 8)}...)`, 'success');

                    // 显示YAML配置文件的GitHub.io链接（复用mergedYamlLink）
                    showGithubLink('mergedYamlLink', 'mergedYamlUrl', yamlResult.githubIoUrl);
                } catch (yamlError) {
                    console.warn('YAML文件上传失败，但节点文件已成功上传:', yamlError);
                    showNotification('YAML上传失败', '节点文件上传成功，但YAML配置文件上传失败: ' + yamlError.message, 'warning');
                }
            } catch (e) {
                showNotification('上传失败', '上传过程中发生错误: ' + e.message, 'error');
                addLog('上传合并至指定路径', '上传失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'uploadMergedToPathBtn');
            }
        }

        //一键同步(远端明文和本地明文)和(远端Base64和本地Base64)方法
        async function oneClickSync() {
            showLoading(true, 'syncBtn');
            try {
                // 1. 解析本地节点
                if (data.vlessLinks.length === 0) {
                    await generateVless();
                    if (data.vlessLinks.length === 0) throw new Error('无本地节点可同步');
                }

                // 2. 从GitHub下载远程节点
                await downloadRemote();

                // 3. 合并去重
                mergeAndShow();

                // 4. 保存令牌
                const token = document.getElementById('githubToken').value.trim();
                if (!token) throw new Error('缺少GitHub Token');
                if (document.getElementById('saveToken').checked) localStorage.setItem('github_token', token);

                // 5. 获取配置
                const mainNodeFile = document.getElementById('mainNodeFile').value.trim();
                const plainNodeFile = document.getElementById('plainNodeFile').value.trim();
                const optimalNodeFile = document.getElementById('optimalNodeFile').value.trim();
                const plainText = data.uniqueNodes.join('\n');

                // 双重Base64编码
                const firstBase64 = btoa(plainText);
                const finalContent = btoa(firstBase64);

                // 6. 上传Base64订阅文件（MainNode）- 双重Base64编码
                const mainResult = await uploadToGitHub(
                    mainNodeFile,
                    finalContent,
                    true,
                    `一键同步更新MainNode - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                );

                console.log('✅ MainNode 上传成功');

                // 7. 上传明文文件（PlainNode）
                try {
                    await uploadToGitHub(
                        plainNodeFile,
                        btoa(plainText),
                        false,
                        `一键同步明文节点到PlainNode - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                    );
                    console.log('✅ PlainNode 上传成功');
                } catch (e) {
                    console.warn('⚠️ PlainNode 上传失败，但MainNode已成功上传:', e);
                    // 不抛出错误，继续执行
                }

                // 8. 上传合并订阅到OptimalNode
                try {
                    await uploadToGitHub(
                        optimalNodeFile,
                        finalContent,
                        true,
                        `一键同步合并订阅到OptimalNode - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                    );
                    console.log('✅ OptimalNode 上传成功');
                } catch (e) {
                    console.warn('⚠️ OptimalNode 上传失败，但其他文件已成功上传:', e);
                    // 不抛出错误，继续执行
                }

                // 9. 上传对应的YAML配置文件
                try {
                    const yamlFileName = mainNodeFile.replace(/\.[^/.]+$/, '') + '.yaml';
                    const yamlContent = data.mergedYamlContent;

                    await uploadToGitHub(
                        yamlFileName,
                        utf8ToBase64(yamlContent),
                        false,
                        `一键同步YAML配置 ${yamlFileName} - ${new Date().toLocaleString()} (${data.uniqueNodes.length}节点)`
                    );
                    console.log('✅ YAML配置 上传成功');
                } catch (e) {
                    console.warn('⚠️ YAML配置上传失败，但其他文件已成功上传:', e);
                    // 不抛出错误，继续执行
                }

                // 10. 清除缓存更新标记
                data.cache.needsUpdate = false;

                showNotification('一键同步成功', `成功同步 ${data.uniqueNodes.length} 个节点到GitHub三个文件和YAML配置，所有操作已完成！`, 'success');
                addLog('一键同步', `成功同步 ${data.uniqueNodes.length} 个节点到GitHub三个文件和YAML配置`, 'success');
            } catch (e) {
                showNotification('一键同步失败', '同步过程中发生错误: ' + e.message, 'error');
                addLog('一键同步', '同步失败: ' + e.message, 'error');
            } finally {
                showLoading(false, 'syncBtn');
            }
        }

        // 显示GitHub.io链接的函数
        function showGithubLink(linkId, urlId, url) {
            const linkItem = document.getElementById(linkId);
            const urlInput = document.getElementById(urlId);
            const linksSection = document.getElementById('githubLinksSection');

            if (linkItem && urlInput) {
                urlInput.value = url;
                linkItem.style.display = 'block';
                linksSection.style.display = 'block';
            }
        }

        // 复制GitHub.io链接的函数
        function copyGithubUrl(urlId) {
            const urlInput = document.getElementById(urlId);
            if (urlInput && urlInput.value) {
                copyText(urlInput.value);
                showNotification('复制成功', 'GitHub.io链接已复制到剪贴板', 'success');
            }
        }

        // 下载代理工具配置文件的函数
        function downloadProxyConfig(toolType) {
            // 优先使用本地生成的Vless节点，如果没有则使用合并后的节点
            const nodes = data.vlessLinks.length > 0 ? data.vlessLinks : (data.uniqueNodes.length > 0 ? data.uniqueNodes : []);

            if (nodes.length === 0) {
                showNotification('下载失败', '没有可用的节点数据，请先生成Vless节点', 'error');
                return;
            }

            let content = '';
            let filename = '';
            let mimeType = 'text/plain';

            if (toolType === 'clash') {
                content = generateClashYAML(nodes);
                filename = `clash-config-${new Date().toISOString().split('T')[0]}.yaml`;
                mimeType = 'application/x-yaml';
            } else {
                showNotification('错误', '不支持的代理工具类型', 'error');
                return;
            }

            // 创建并下载文件
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('下载成功', `${filename} 已下载`, 'success');
            addLog('配置文件下载', `下载了 Clash 配置文件，包含 ${nodes.length} 个节点`, 'success');
        }

        // 生成Clash YAML配置
        function generateClashYAML(nodes) {
            const proxies = [];
            const proxyNames = [];

            nodes.forEach((node, index) => {
                try {
                    const parsed = parseVlessUrl(node);
                    if (parsed) {
                        const proxyName = parsed.name || `节点${index + 1}`;
                        proxyNames.push(proxyName);

                        const proxy = {
                            name: proxyName,
                            type: 'vless',
                            server: parsed.server,
                            port: parsed.port,
                            uuid: parsed.uuid,
                            network: parsed.network || 'tcp',
                            tls: parsed.tls,
                            'skip-cert-verify': parsed.skipCertVerify || false,
                            udp: true
                        };

                        // 添加SNI
                        if (parsed.sni) {
                            proxy.sni = parsed.sni;
                        }

                        // 添加ALPN
                        if (parsed.alpn) {
                            proxy.alpn = parsed.alpn.split(',');
                        }

                        // 添加flow (XTLS)
                        if (parsed.flow) {
                            proxy.flow = parsed.flow;
                        }

                        // 添加ws配置
                        if (parsed.network === 'ws') {
                            proxy['ws-opts'] = {
                                path: parsed.wsPath || '/',
                                headers: parsed.wsHeaders || {}
                            };
                        }

                        proxies.push(proxy);
                    }
                } catch (e) {
                    console.warn(`跳过无效节点: ${node}`, e);
                }
            });

            const config = {
                port: 7890,
                'socks-port': 7891,
                'redir-port': 7892,
                'mixed-port': 7893,
                'tproxy-port': 7895,
                'allow-lan': true,
                mode: 'rule',
                'log-level': 'info',
                ipv6: false,
                'external-controller': '127.0.0.1:9090',
                dns: {
                    enable: true,
                    ipv6: false,
                    'enhanced-mode': 'fake-ip',
                    'fake-ip-range': '198.18.0.1/16',
                    nameserver: [
                        '114.114.114.114',
                        '223.5.5.5',
                        '8.8.8.8',
                        '1.1.1.1'
                    ]
                },
                proxies: proxies,
                'proxy-groups': [
                    {
                        name: '🚀 节点选择',
                        type: 'select',
                        proxies: proxyNames
                    },
                    {
                        name: '♻️ 自动选择',
                        type: 'url-test',
                        proxies: proxyNames,
                        url: 'http://www.gstatic.com/generate_204',
                        interval: 300
                    },
                    {
                        name: '🔥 故障转移',
                        type: 'fallback',
                        proxies: proxyNames,
                        url: 'http://www.gstatic.com/generate_204',
                        interval: 300
                    }
                ],
                rules: [
                    'DOMAIN-SUFFIX,google.com,🚀 节点选择',
                    'DOMAIN-SUFFIX,youtube.com,🚀 节点选择',
                    'DOMAIN-SUFFIX,github.com,🚀 节点选择',
                    'DOMAIN-SUFFIX,twitter.com,🚀 节点选择',
                    'DOMAIN-SUFFIX,facebook.com,🚀 节点选择',
                    'DOMAIN-SUFFIX,instagram.com,🚀 节点选择',
                    'DOMAIN-SUFFIX,telegram.org,🚀 节点选择',
                    'DOMAIN-SUFFIX,netflix.com,🚀 节点选择',
                    'DOMAIN-SUFFIX,spotify.com,🚀 节点选择',
                    'GEOIP,CN,DIRECT',
                    'MATCH,♻️ 自动选择'
                ]
            };

            // 使用js-yaml库或手动构建YAML格式
            // 由于浏览器环境，我们手动构建YAML格式
            let yamlContent = '';

            // 添加代理配置
            yamlContent += 'proxies:\n';
            proxies.forEach(proxy => {
                yamlContent += '  - name: "' + proxy.name + '"\n';
                yamlContent += '    type: ' + proxy.type + '\n';
                yamlContent += '    server: ' + proxy.server + '\n';
                yamlContent += '    port: ' + proxy.port + '\n';
                yamlContent += '    uuid: ' + proxy.uuid + '\n';
                yamlContent += '    network: ' + proxy.network + '\n';
                yamlContent += '    tls: ' + proxy.tls + '\n';
                yamlContent += '    skip-cert-verify: ' + proxy['skip-cert-verify'] + '\n';
                yamlContent += '    udp: ' + proxy.udp + '\n';

                // 添加SNI
                if (proxy.sni) {
                    yamlContent += '    sni: "' + proxy.sni + '"\n';
                }

                // 添加ALPN
                if (proxy.alpn && Array.isArray(proxy.alpn)) {
                    yamlContent += '    alpn:\n';
                    proxy.alpn.forEach(alpn => {
                        yamlContent += '      - "' + alpn.trim() + '"\n';
                    });
                }

                // 添加flow (XTLS)
                if (proxy.flow) {
                    yamlContent += '    flow: "' + proxy.flow + '"\n';
                }

                if (proxy['ws-opts']) {
                    yamlContent += '    ws-opts:\n';
                    yamlContent += '      path: "' + proxy['ws-opts'].path + '"\n';
                    if (proxy['ws-opts'].headers && Object.keys(proxy['ws-opts'].headers).length > 0) {
                        yamlContent += '      headers:\n';
                        Object.entries(proxy['ws-opts'].headers).forEach(([key, value]) => {
                            yamlContent += '        ' + key + ': "' + value + '"\n';
                        });
                    }
                }
                yamlContent += '\n';
            });

            // 添加代理组
            yamlContent += 'proxy-groups:\n';
            config['proxy-groups'].forEach(group => {
                yamlContent += '  - name: "' + group.name + '"\n';
                yamlContent += '    type: ' + group.type + '\n';
                yamlContent += '    proxies:\n';
                group.proxies.forEach(proxy => {
                    yamlContent += '      - "' + proxy + '"\n';
                });
                if (group.url) {
                    yamlContent += '    url: "' + group.url + '"\n';
                }
                if (group.interval) {
                    yamlContent += '    interval: ' + group.interval + '\n';
                }
                yamlContent += '\n';
            });

            // 添加规则
            yamlContent += 'rules:\n';
            config.rules.forEach(rule => {
                yamlContent += '  - ' + rule + '\n';
            });

            // 添加其他配置
            yamlContent += '\nport: 7890\n';
            yamlContent += 'socks-port: 7891\n';
            yamlContent += 'redir-port: 7892\n';
            yamlContent += 'mixed-port: 7893\n';
            yamlContent += 'tproxy-port: 7895\n';
            yamlContent += 'allow-lan: true\n';
            yamlContent += 'mode: rule\n';
            yamlContent += 'log-level: info\n';
            yamlContent += 'ipv6: false\n';
            yamlContent += 'external-controller: 127.0.0.1:9090\n';

            return yamlContent;
        }

        // 解析Vless URL的辅助函数
        function parseVlessUrl(url) {
            try {
                // 检查是否是vless协议
                if (!url.startsWith('vless://')) {
                    return null;
                }

                // 移除协议部分
                let urlWithoutProtocol = url.substring(8); // 移除 'vless://'

                // 处理包含#的URL，需要小心处理fragment
                let urlWithoutFragment = urlWithoutProtocol;
                let remarks = '';

                // 检查是否有fragment（#后面的内容）
                const hashIndex = urlWithoutProtocol.indexOf('#');
                if (hashIndex !== -1) {
                    urlWithoutFragment = urlWithoutProtocol.substring(0, hashIndex);
                    remarks = urlWithoutProtocol.substring(hashIndex + 1);
                    // URL解码remarks
                    try {
                        remarks = decodeURIComponent(remarks);
                    } catch (e) {
                        // 如果解码失败，保持原样
                    }
                }

                // 分离路径和查询参数
                const queryIndex = urlWithoutFragment.indexOf('?');
                let pathPart = urlWithoutFragment;
                let queryPart = '';

                if (queryIndex !== -1) {
                    pathPart = urlWithoutFragment.substring(0, queryIndex);
                    queryPart = urlWithoutFragment.substring(queryIndex + 1);
                }

                // 解析路径部分: uuid@server:port
                const pathParts = pathPart.split('@');
                if (pathParts.length !== 2) {
                    return null;
                }

                const uuid = pathParts[0];
                const serverPort = pathParts[1].split(':');

                if (serverPort.length !== 2) {
                    return null;
                }

                const server = serverPort[0];
                const port = parseInt(serverPort[1]);

                if (!uuid || !server || isNaN(port)) {
                    return null;
                }

                // 解析查询参数
                const params = {};
                if (queryPart) {
                    const paramPairs = queryPart.split('&');
                    paramPairs.forEach(pair => {
                        const [key, value] = pair.split('=');
                        params[key] = value || '';
                    });
                }

                return {
                    uuid: uuid,
                    server: server,
                    port: port,
                    name: params.name || remarks || `节点-${server}:${port}`,
                    network: params.type || 'tcp',
                    tls: params.security === 'tls',
                    wsPath: params.path ? decodeURIComponent(params.path) : '/',
                    wsHeaders: params.host ? { Host: params.host } : {},
                    skipCertVerify: params.allowInsecure === '1' || params.fp === 'chrome',
                    encryption: params.encryption || 'none',
                    sni: params.sni,
                    alpn: params.alpn,
                    flow: params.flow
                };
            } catch (e) {
                console.warn('解析Vless URL失败:', url, e);
                return null;
            }
        }

        // 新增：全局通知函数
        function showNotification(title, message, type = 'info') {
            const notificationId = 'notification-' + Date.now();
            const notificationContainer = document.getElementById('notificationContainer');

            // 限制通知数量
            if (notifications.active.length >= notifications.maxNotifications) {
                const oldestNotification = document.getElementById(notifications.active[0]);
                if (oldestNotification) {
                    oldestNotification.remove();
                    notifications.active.shift();
                }
            }

            const notification = document.createElement('div');
            notification.id = notificationId;
            notification.className = `notification ${type}`;

            const time = new Date().toLocaleTimeString();

            notification.innerHTML = `
            <div class="notification-header">
                <div class="notification-title">${title}</div>
                <div class="notification-time">${time}</div>
                <button class="notification-close" onclick="closeNotification('${notificationId}')">&times;</button>
            </div>
            <div class="notification-message">${message}</div>
        `;

            notificationContainer.appendChild(notification);
            notifications.active.push(notificationId);

            // 自动关闭通知（错误通知不自动关闭）
            if (type !== 'error') {
                let timeoutDuration = 6000; // 默认6秒

                // 根据类型设置不同时间
                if (type === 'success') {
                    timeoutDuration = 3000; // 成功通知显示3秒
                } else if (type === 'info') {
                    timeoutDuration = 4000; // 信息通知显示4秒
                } else if (type === 'warning') {
                    timeoutDuration = 8000; // 警告通知显示8秒
                }

                setTimeout(() => {
                    closeNotification(notificationId);
                }, timeoutDuration);
            } else {
                setTimeout(() => {
                    closeNotification(notificationId);
                }, 15000); // 错误通知显示15秒
            }
        }

        // 新增：关闭通知函数
        function closeNotification(id) {
            const notification = document.getElementById(id);
            if (notification) {
                notification.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => {
                    notification.remove();
                    const index = notifications.active.indexOf(id);
                    if (index > -1) {
                        notifications.active.splice(index, 1);
                    }
                }, 300);
            }
        }

        // 新增：添加日志函数
        function addLog(action, message, level = 'info') {
            const time = new Date().toLocaleTimeString();
            const logEntry = {
                time,
                action,
                message,
                level,
                timestamp: Date.now()
            };

            logData.entries.unshift(logEntry);

            // 限制日志条目数量
            if (logData.entries.length > logData.maxEntries) {
                logData.entries.pop();
            }

            updateLogDisplay();
        }

        // 新增：更新日志显示
        function updateLogDisplay() {
            const logContent = document.getElementById('logContent');
            logContent.innerHTML = '';

            logData.entries.forEach(entry => {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';

                const levelClass = {
                    'info': 'info',
                    'success': 'success',
                    'error': 'error'
                }[entry.level] || 'info';

                logEntry.innerHTML = `
                <span class="log-time">[${entry.time}]</span>
                <span class="log-level ${levelClass}">${levelClass}</span>
                <span class="log-message">${entry.action}: ${entry.message}</span>
            `;

                logContent.appendChild(logEntry);
            });

            // 自动显示日志区域
            const logSection = document.getElementById('logSection');
            if (logData.entries.length > 1) { // 不止有启动日志
                logSection.classList.add('show');
            }
        }

        // 新增：清空日志
        function clearLog() {
            logData.entries = [];
            updateLogDisplay();
            showNotification('日志已清空', '所有操作日志记录已被清除', 'info');
            addLog('系统', '日志已清空', 'info');
        }

        // 新增：切换日志显示
        function toggleLog() {
            const logSection = document.getElementById('logSection');
            const toggleBtn = document.getElementById('toggleLogBtn');

            if (logSection.classList.contains('show')) {
                logSection.classList.remove('show');
                toggleBtn.innerHTML = '<span>📋</span> 收起日志';
            } else {
                logSection.classList.add('show');
                toggleBtn.innerHTML = '<span>📋</span> 展开日志';
            }
        }

        function loadSavedToken() {
            const token = localStorage.getItem('github_token');
            if (token) {
                document.getElementById('githubToken').value = token;
                console.log('✅ 从本地存储加载GitHub令牌');
            }
        }

        function updateStats() {
            const s = data.stats;
            const el = document.getElementById('githubStats');
            el.style.display = s.local + s.remote > 0 ? 'flex' : 'none';
            document.getElementById('localNodes').textContent = s.local;
            document.getElementById('remoteNodes').textContent = s.remote;
            document.getElementById('mergedNodes').textContent = s.merged;
            document.getElementById('uniqueNodes').textContent = s.unique;
            document.getElementById('syncNodeCount').textContent = `${s.unique}节点`;
        }

        function showLoading(show, buttonId = null) {
            if (buttonId) {
                // 按钮级别加载动画
                const button = document.getElementById(buttonId);
                if (button) {
                    if (show) {
                        button.classList.add('btn-loading');
                        button.disabled = true;
                    } else {
                        button.classList.remove('btn-loading');
                        button.disabled = false;
                    }
                }
            } else {
                // 全局加载动画（保留作为后备）
                document.getElementById('loading').style.display = show ? 'block' : 'none';
            }
        }

        function copyText(text) {
            if (!text) {
                showNotification('复制失败', '无内容可复制，请先生成或获取节点数据', 'error');
                return;
            }
            navigator.clipboard.writeText(text).then(() => {
                showNotification('复制成功', '内容已成功复制到剪贴板，可以粘贴到其他应用了', 'success');
                addLog('复制操作', '内容已复制到剪贴板', 'success');
            }).catch(err => {
                showNotification('复制失败', '无法复制到剪贴板: ' + err.message, 'error');
                addLog('复制操作', '复制失败: ' + err.message, 'error');
            });
        }

        // 移除downloadVless函数，只保留downloadAll函数
        function downloadAll() {
            if (!data.vlessLinks.length) {
                showNotification('下载失败', '请先生成节点，当前没有可下载的数据', 'error');
                return;
            }
            const t = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            downloadBlob(data.vlessLinks.join('\n'), `vless_${t}.txt`);
            downloadBlob(data.localBase64Content || btoa(data.vlessLinks.join('\n')), `subscription_${t}.txt`);
            showNotification('下载成功', '已下载Vless链接和订阅文件到本地，请查看下载文件夹', 'success');
            addLog('下载', '已下载Vless链接和订阅文件到本地', 'success');
        }

        function downloadBlob(content, name) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            a.click();
            URL.revokeObjectURL(url);
        }

        function readFile(file) {
            return new Promise((res, rej) => {
                const r = new FileReader();
                r.onload = e => res(e.target.result);
                r.onerror = rej;
                r.readAsText(file);
            });
        }

        function formatSize(b) {
            const units = ['B', 'KB', 'MB', 'GB'];
            let i = 0;
            while (b >= 1024 && i < units.length - 1) { b /= 1024; i++; }
            return b.toFixed(1) + ' ' + units[i];
        }

        function isValidIP(ip) {
            if (!ip || typeof ip !== 'string') return false;

            const parts = ip.split('.');
            if (parts.length !== 4) return false;

            for (let i = 0; i < 4; i++) {
                const part = parseInt(parts[i], 10);
                if (isNaN(part) || part < 0 || part > 255) return false;
                // 检查前导零（除了0本身）
                if (parts[i].length > 1 && parts[i][0] === '0') return false;
            }

            return true;
        }


        function copyGitToken() {
            const token = "ghp_q914mARHjefJJ8XDKoNFauxzubjcjV0nlLt";
            const input = document.createElement('input');
            input.value = token;
            document.body.appendChild(input);
            input.select();
            document.execCommand('copy');
            document.body.removeChild(input);
            showNotification('复制成功', '示例令牌已复制到剪贴板', 'success');
        }
        // 二维码模态及生成函数（使用外部API但带浏览器缓存，离线有友好降级）
        function showQR(targetUrl, label = '') {
            if (!targetUrl) {
                showNotification('二维码', '没有可生成的链接', 'warning');
                return;
            }

            const size = 320;
            const apiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(targetUrl)}`;

            // 使用可读的缓存键（base64的URL）
            const cacheKey = 'qr_cache_' + btoa(unescape(encodeURIComponent(targetUrl))).replace(/=/g, '');

            let modal = document.getElementById('qrModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'qrModal';
                modal.className = 'custom-dialog-overlay';
                modal.innerHTML = `
                    <div class="custom-dialog">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
                            <div style="font-weight:700">二维码预览</div>
                            <button id="closeQrBtn" class="custom-dialog-btn custom-dialog-btn-cancel">关闭</button>
                        </div>
                        <div style="text-align:center;">
                            <div id="qrSpinner" style="margin-bottom:8px;display:none;">生成中...</div>
                            <img id="qrImage" src="" alt="qr" style="max-width:100%;height:auto;border-radius:8px;border:1px solid #e2e8f0;" />
                            <div id="qrLabel" style="margin-top:10px;font-size:13px;color:#4a5568;"></div>
                            <div style="margin-top:12px;display:flex;gap:8px;justify-content:center;">
                                <a id="downloadQrLink" class="btn btn-primary btn-sm" href="#" download="qr.png">下载二维码</a>
                            </div>
                        </div>
                    </div>`;
                document.body.appendChild(modal);
                document.getElementById('closeQrBtn').addEventListener('click', () => modal.remove());
            }

            const img = modal.querySelector('#qrImage');
            const dl = modal.querySelector('#downloadQrLink');
            const labelEl = modal.querySelector('#qrLabel');
            const spinner = modal.querySelector('#qrSpinner');

            labelEl.textContent = label || '';
            modal.style.display = 'flex';

            // 如果已缓存dataURL，则直接使用（避免重复网络请求）
            try {
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    img.src = cached;
                    dl.href = cached;
                    return;
                }
            } catch (e) {
                console.warn('读取QR缓存失败', e);
            }

            // 若离线且无缓存，提示用户
            if (!navigator.onLine) {
                showNotification('离线', '当前网络不可用，且无已缓存二维码，无法生成。', 'error');
                img.src = '';
                dl.href = '';
                return;
            }

            // 优先尝试本地生成（动态加载qrcode库），若无法加载再按顺序尝试多个外部API
            spinner.style.display = 'block';
            img.style.opacity = '0.4';

            function loadScript(url) {
                return new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = url;
                    s.onload = () => resolve();
                    s.onerror = () => reject(new Error('加载脚本失败: ' + url));
                    document.head.appendChild(s);
                });
            }

            // 尝试在页面中使用 qrcodejs（如果已存在直接使用）
            async function tryLocalGenerate() {
                if (!window.QRCode) {
                    // 从 CDN 动态加载（用户可根据网络调整）
                    try {
                        await loadScript('https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js');
                    } catch (e) {
                        console.warn('本地二维码库加载失败', e);
                        return null;
                    }
                }

                try {
                    const tmp = document.createElement('div');
                    tmp.style.position = 'absolute';
                    tmp.style.left = '-9999px';
                    document.body.appendChild(tmp);
                    // 生成到临时容器
                    const qrcode = new QRCode(tmp, { text: targetUrl, width: size, height: size, correctLevel: QRCode.CorrectLevel.H });
                    // QRCode库会生成img或canvas，等待微任务
                    await new Promise(resolve => setTimeout(resolve, 50));
                    let dataUrl = '';
                    const imgEl = tmp.querySelector('img');
                    const canvasEl = tmp.querySelector('canvas');
                    if (imgEl && imgEl.src) {
                        dataUrl = imgEl.src;
                    } else if (canvasEl) {
                        dataUrl = canvasEl.toDataURL('image/png');
                    }
                    document.body.removeChild(tmp);
                    if (dataUrl) return dataUrl;
                } catch (e) {
                    console.warn('本地生成二维码失败', e);
                }
                return null;
            }

            // 外部服务备选（优先中国友好服务）
            const externalCandidates = [
                // 草料二维码变体（优先）
                // 已移除无效的 `https://cli.im/api?text=` 入口，保留有效的 qrcode 接口作为首选
                `https://cli.im/api/qrcode?text=${encodeURIComponent(targetUrl)}&w=${size}`,
                // api.qrserver.com（原先使用）
                `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(targetUrl)}`,
                // Google Chart（有时可用）
                `https://chart.googleapis.com/chart?chs=${size}x${size}&cht=qr&chl=${encodeURIComponent(targetUrl)}`
            ];

            // 备用：通过直接加载 <img> 的方式回退（不转换为dataURL）
            function tryImageLoad(url) {
                return new Promise((resolve) => {
                    const testImg = new Image();
                    testImg.onload = () => resolve(true);
                    testImg.onerror = () => resolve(false);
                    testImg.src = url;
                    // 超时处理
                    setTimeout(() => resolve(false), 4000);
                });
            }

            (async () => {
                try {
                    // 1) 本地生成
                    const localData = await tryLocalGenerate();
                    if (localData) {
                        img.src = localData;
                        dl.href = localData;
                        spinner.style.display = 'none';
                        img.style.opacity = '1';
                        try { localStorage.setItem(cacheKey, localData); } catch (e) { }
                        return;
                    }

                    // 2) 使用外部候选按序尝试并缓存首个成功结果
                    for (const urlCandidate of externalCandidates) {
                        try {
                            const res = await fetch(urlCandidate);
                            if (!res.ok) throw new Error('服务返回' + res.status);
                            const blob = await res.blob();
                            const dataUrl = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onloadend = () => resolve(reader.result);
                                reader.onerror = reject;
                                reader.readAsDataURL(blob);
                            });
                            img.src = dataUrl;
                            dl.href = dataUrl;
                            spinner.style.display = 'none';
                            img.style.opacity = '1';
                            try { localStorage.setItem(cacheKey, dataUrl); } catch (e) { }
                            return;
                        } catch (e) {
                            console.warn('外部候选 fetch 失败', urlCandidate, e);
                            // 回退：尝试直接以 img.src 加载（无法转换为dataURL但可显示）
                            try {
                                const ok = await tryImageLoad(urlCandidate);
                                if (ok) {
                                    img.src = urlCandidate;
                                    dl.href = urlCandidate;
                                    spinner.style.display = 'none';
                                    img.style.opacity = '1';
                                    showNotification('二维码', '已使用图片直链回退显示（可能无法缓存）', 'info');
                                    return;
                                }
                            } catch (ie) {
                                console.warn('直接加载图片回退失败', ie);
                            }
                            continue;
                        }
                    }

                    // 3) 最后回退到使用apiUrl直接赋值（可能无法绕过CORS）
                    img.src = apiUrl;
                    dl.href = apiUrl;
                    spinner.style.display = 'none';
                    img.style.opacity = '1';
                    showNotification('二维码生成说明', '尝试了本地与多个外部服务均失败，已回退到直链显示，可能受CORS或网络限制。', 'warning');
                } catch (e) {
                    console.error('二维码生成最终失败', e);
                    spinner.style.display = 'none';
                    img.style.opacity = '1';
                    img.src = apiUrl;
                    dl.href = apiUrl;
                    showNotification('二维码生成失败', e.message || String(e), 'error');
                }
            })();
        }
        /**
         * 获取IP地址对应的国家/地区名称
         * @param {string} ip - IPv4地址
         * @returns {string} - 国家/地区名称或地区范围
         */
        function getLocation(ip) {
            // 使用 window.IPGeolocationService.getIPLocation 函数获取IP地址对应的国家/地区名称
            return window.IPGeolocationService.getIPLocation(ip);
        }

    </script>
</body>

</html>